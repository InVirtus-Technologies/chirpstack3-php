<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: api/device_profile.proto

namespace Chirpstack\Api;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Generated from protobuf message <code>api.DeviceProfile</code>
 */
class DeviceProfile extends \Google\Protobuf\Internal\Message
{
    /**
     * Device-profile ID (UUID).
     * Note: on create this will be automatically generated.
     *
     * Generated from protobuf field <code>string id = 1;</code>
     */
    protected $id = '';
    /**
     * Tenant ID (UUID).
     *
     * Generated from protobuf field <code>string tenant_id = 2;</code>
     */
    protected $tenant_id = '';
    /**
     * Name.
     *
     * Generated from protobuf field <code>string name = 3;</code>
     */
    protected $name = '';
    /**
     * Description.
     *
     * Generated from protobuf field <code>string description = 26;</code>
     */
    protected $description = '';
    /**
     * Region.
     *
     * Generated from protobuf field <code>.common.Region region = 4;</code>
     */
    protected $region = 0;
    /**
     * LoRaWAN mac-version.
     *
     * Generated from protobuf field <code>.common.MacVersion mac_version = 5;</code>
     */
    protected $mac_version = 0;
    /**
     * Regional parameters revision.
     *
     * Generated from protobuf field <code>.common.RegParamsRevision reg_params_revision = 6;</code>
     */
    protected $reg_params_revision = 0;
    /**
     * ADR algorithm ID.
     *
     * Generated from protobuf field <code>string adr_algorithm_id = 7;</code>
     */
    protected $adr_algorithm_id = '';
    /**
     * Payload codec runtime.
     *
     * Generated from protobuf field <code>.api.CodecRuntime payload_codec_runtime = 8;</code>
     */
    protected $payload_codec_runtime = 0;
    /**
     * Payload codec script.
     *
     * Generated from protobuf field <code>string payload_codec_script = 9;</code>
     */
    protected $payload_codec_script = '';
    /**
     * Flush queue on device activation.
     *
     * Generated from protobuf field <code>bool flush_queue_on_activate = 10;</code>
     */
    protected $flush_queue_on_activate = false;
    /**
     * Uplink interval (seconds).
     * This defines the expected uplink interval which the device uses for
     * communication. If the uplink interval has expired and no uplink has
     * been received, the device is considered inactive.
     *
     * Generated from protobuf field <code>uint32 uplink_interval = 11;</code>
     */
    protected $uplink_interval = 0;
    /**
     * Device-status request interval (times / day).
     * This defines the times per day that ChirpStack will request the
     * device-status from the device.
     *
     * Generated from protobuf field <code>uint32 device_status_req_interval = 12;</code>
     */
    protected $device_status_req_interval = 0;
    /**
     * Supports OTAA.
     *
     * Generated from protobuf field <code>bool supports_otaa = 13;</code>
     */
    protected $supports_otaa = false;
    /**
     * Supports Class B.
     *
     * Generated from protobuf field <code>bool supports_class_b = 14;</code>
     */
    protected $supports_class_b = false;
    /**
     * Supports Class-C.
     *
     * Generated from protobuf field <code>bool supports_class_c = 15;</code>
     */
    protected $supports_class_c = false;
    /**
     * Class-B timeout (seconds).
     * This is the maximum time ChirpStack will wait to receive an acknowledgement
     * from the device (if requested).
     *
     * Generated from protobuf field <code>uint32 class_b_timeout = 16;</code>
     */
    protected $class_b_timeout = 0;
    /**
     * Class-B ping-slots per beacon period.
     * Valid options are: 0 - 7.
     * The actual number of ping-slots per beacon period equals to 2^k.
     *
     * Generated from protobuf field <code>uint32 class_b_ping_slot_nb_k = 17;</code>
     */
    protected $class_b_ping_slot_nb_k = 0;
    /**
     * Class-B ping-slot DR.
     *
     * Generated from protobuf field <code>uint32 class_b_ping_slot_dr = 18;</code>
     */
    protected $class_b_ping_slot_dr = 0;
    /**
     * Class-B ping-slot freq (Hz).
     *
     * Generated from protobuf field <code>uint32 class_b_ping_slot_freq = 19;</code>
     */
    protected $class_b_ping_slot_freq = 0;
    /**
     * Class-C timeout (seconds).
     * This is the maximum time ChirpStack will wait to receive an acknowledgement
     * from the device (if requested).
     *
     * Generated from protobuf field <code>uint32 class_c_timeout = 20;</code>
     */
    protected $class_c_timeout = 0;
    /**
     * RX1 delay (for ABP).
     *
     * Generated from protobuf field <code>uint32 abp_rx1_delay = 21;</code>
     */
    protected $abp_rx1_delay = 0;
    /**
     * RX1 DR offset (for ABP).
     *
     * Generated from protobuf field <code>uint32 abp_rx1_dr_offset = 22;</code>
     */
    protected $abp_rx1_dr_offset = 0;
    /**
     * RX2 DR (for ABP).
     *
     * Generated from protobuf field <code>uint32 abp_rx2_dr = 23;</code>
     */
    protected $abp_rx2_dr = 0;
    /**
     * RX2 frequency (for ABP, Hz).
     *
     * Generated from protobuf field <code>uint32 abp_rx2_freq = 24;</code>
     */
    protected $abp_rx2_freq = 0;
    /**
     * Tags (user defined).
     * These tags can be used to add additional information the the
     * device-profile. These tags are exposed in all the integration events of
     * devices using this device-profile.
     *
     * Generated from protobuf field <code>map<string, string> tags = 25;</code>
     */
    private $tags;
    /**
     * Measurements.
     * If defined, ChirpStack will visualize these metrics in the web-interface.
     *
     * Generated from protobuf field <code>map<string, .api.Measurement> measurements = 27;</code>
     */
    private $measurements;
    /**
     * Auto-detect measurements.
     * If set to true, measurements will be automatically added based on the
     * keys of the decoded payload. In cases where the decoded payload contains
     * random keys in the data, you want to set this to false.
     *
     * Generated from protobuf field <code>bool auto_detect_measurements = 28;</code>
     */
    protected $auto_detect_measurements = false;
    /**
     * Region configuration ID.
     * If set, devices will only use the associated region. If let blank, then
     * devices will use all regions matching the selected common-name. Note
     * that multiple region configurations can exist for the same common-name,
     * e.g. to provide an 8 channel and 16 channel configuration for the US915
     * band.
     *
     * Generated from protobuf field <code>string region_config_id = 29;</code>
     */
    protected $region_config_id = '';
    /**
     * Device is a Relay device.
     * Enable this in case the device is a Relay. A Relay device implements TS011
     * and is able to relay data from relay capable devices.
     * See for more information the TS011 specification.
     *
     * Generated from protobuf field <code>bool is_relay = 30;</code>
     */
    protected $is_relay = false;
    /**
     * Device is a Relay end-device.
     * Enable this in case the device is an end-device that can operate under a
     * Relay. Please refer to the TS011 specification for more information.
     *
     * Generated from protobuf field <code>bool is_relay_ed = 31;</code>
     */
    protected $is_relay_ed = false;
    /**
     * End-device only accept data through relay.
     * Only accept data for this device through a relay. This setting is useful
     * for testing as in case of a test-setup, the end-device is usually within
     * range of the gateway.
     *
     * Generated from protobuf field <code>bool relay_ed_relay_only = 32;</code>
     */
    protected $relay_ed_relay_only = false;
    /**
     * Relay must be enabled.
     *
     * Generated from protobuf field <code>bool relay_enabled = 33;</code>
     */
    protected $relay_enabled = false;
    /**
     * Relay CAD periodicity.
     *
     * Generated from protobuf field <code>.api.CadPeriodicity relay_cad_periodicity = 34;</code>
     */
    protected $relay_cad_periodicity = 0;
    /**
     * Relay default channel index.
     * Valid values are 0 and 1, please refer to the RP002 specification for
     * the meaning of these values.
     *
     * Generated from protobuf field <code>uint32 relay_default_channel_index = 35;</code>
     */
    protected $relay_default_channel_index = 0;
    /**
     * Relay second channel frequency (Hz).
     *
     * Generated from protobuf field <code>uint32 relay_second_channel_freq = 36;</code>
     */
    protected $relay_second_channel_freq = 0;
    /**
     * Relay second channel DR.
     *
     * Generated from protobuf field <code>uint32 relay_second_channel_dr = 37;</code>
     */
    protected $relay_second_channel_dr = 0;
    /**
     * Relay second channel ACK offset.
     *
     * Generated from protobuf field <code>.api.SecondChAckOffset relay_second_channel_ack_offset = 38;</code>
     */
    protected $relay_second_channel_ack_offset = 0;
    /**
     * Relay end-device activation mode.
     *
     * Generated from protobuf field <code>.api.RelayModeActivation relay_ed_activation_mode = 39;</code>
     */
    protected $relay_ed_activation_mode = 0;
    /**
     * Relay end-device smart-enable level.
     *
     * Generated from protobuf field <code>uint32 relay_ed_smart_enable_level = 40;</code>
     */
    protected $relay_ed_smart_enable_level = 0;
    /**
     * Relay end-device back-off (in case it does not receive WOR ACK frame).
     * 0 = Always send a LoRaWAN uplink
     * 1..63 = Send a LoRaWAN uplink after X WOR frames without a WOR ACK
     *
     * Generated from protobuf field <code>uint32 relay_ed_back_off = 41;</code>
     */
    protected $relay_ed_back_off = 0;
    /**
     * Relay end-device uplink limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_ed_uplink_limit_bucket_size = 42;</code>
     */
    protected $relay_ed_uplink_limit_bucket_size = 0;
    /**
     * Relay end-device uplink limit reload rate.
     * Valid values:
     *   * 0 - 62 = X tokens every hour
     *   * 63     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_ed_uplink_limit_reload_rate = 43;</code>
     */
    protected $relay_ed_uplink_limit_reload_rate = 0;
    /**
     * Relay join-request limit reload rate.
     * Valid values:
     *   * 0 - 126 = X tokens every hour
     *   * 127     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_join_req_limit_reload_rate = 44;</code>
     */
    protected $relay_join_req_limit_reload_rate = 0;
    /**
     * Relay notify limit reload rate.
     * Valid values:
     *   * 0 - 126 = X tokens every hour
     *   * 127     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_notify_limit_reload_rate = 45;</code>
     */
    protected $relay_notify_limit_reload_rate = 0;
    /**
     * Relay global uplink limit reload rate.
     * Valid values:
     *   * 0 - 126 = X tokens every hour
     *   * 127     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_global_uplink_limit_reload_rate = 46;</code>
     */
    protected $relay_global_uplink_limit_reload_rate = 0;
    /**
     * Relay overall limit reload rate.
     * Valid values:
     *   * 0 - 126 = X tokens every hour
     *   * 127     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_overall_limit_reload_rate = 47;</code>
     */
    protected $relay_overall_limit_reload_rate = 0;
    /**
     * Relay join-request limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_join_req_limit_bucket_size = 48;</code>
     */
    protected $relay_join_req_limit_bucket_size = 0;
    /**
     * Relay notify limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_notify_limit_bucket_size = 49;</code>
     */
    protected $relay_notify_limit_bucket_size = 0;
    /**
     * Relay globak uplink limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_global_uplink_limit_bucket_size = 50;</code>
     */
    protected $relay_global_uplink_limit_bucket_size = 0;
    /**
     * Relay overall limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_overall_limit_bucket_size = 51;</code>
     */
    protected $relay_overall_limit_bucket_size = 0;
    /**
     * Allow roaming.
     * If set to true, it means that the device is allowed to use roaming.
     *
     * Generated from protobuf field <code>bool allow_roaming = 52;</code>
     */
    protected $allow_roaming = false;
    /**
     * RX1 Delay.
     * This makes it possible to override the system RX1 Delay. Please note that
     * this values only has effect in case it is higher than the system value.
     * In other words, it can be used to increase the RX1 Delay but not to decrease
     * it.
     * Valid options are 1 - 15 (0 = always use system RX1 Delay).
     *
     * Generated from protobuf field <code>uint32 rx1_delay = 53;</code>
     */
    protected $rx1_delay = 0;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $id
     *           Device-profile ID (UUID).
     *           Note: on create this will be automatically generated.
     *     @type string $tenant_id
     *           Tenant ID (UUID).
     *     @type string $name
     *           Name.
     *     @type string $description
     *           Description.
     *     @type int $region
     *           Region.
     *     @type int $mac_version
     *           LoRaWAN mac-version.
     *     @type int $reg_params_revision
     *           Regional parameters revision.
     *     @type string $adr_algorithm_id
     *           ADR algorithm ID.
     *     @type int $payload_codec_runtime
     *           Payload codec runtime.
     *     @type string $payload_codec_script
     *           Payload codec script.
     *     @type bool $flush_queue_on_activate
     *           Flush queue on device activation.
     *     @type int $uplink_interval
     *           Uplink interval (seconds).
     *           This defines the expected uplink interval which the device uses for
     *           communication. If the uplink interval has expired and no uplink has
     *           been received, the device is considered inactive.
     *     @type int $device_status_req_interval
     *           Device-status request interval (times / day).
     *           This defines the times per day that ChirpStack will request the
     *           device-status from the device.
     *     @type bool $supports_otaa
     *           Supports OTAA.
     *     @type bool $supports_class_b
     *           Supports Class B.
     *     @type bool $supports_class_c
     *           Supports Class-C.
     *     @type int $class_b_timeout
     *           Class-B timeout (seconds).
     *           This is the maximum time ChirpStack will wait to receive an acknowledgement
     *           from the device (if requested).
     *     @type int $class_b_ping_slot_nb_k
     *           Class-B ping-slots per beacon period.
     *           Valid options are: 0 - 7.
     *           The actual number of ping-slots per beacon period equals to 2^k.
     *     @type int $class_b_ping_slot_dr
     *           Class-B ping-slot DR.
     *     @type int $class_b_ping_slot_freq
     *           Class-B ping-slot freq (Hz).
     *     @type int $class_c_timeout
     *           Class-C timeout (seconds).
     *           This is the maximum time ChirpStack will wait to receive an acknowledgement
     *           from the device (if requested).
     *     @type int $abp_rx1_delay
     *           RX1 delay (for ABP).
     *     @type int $abp_rx1_dr_offset
     *           RX1 DR offset (for ABP).
     *     @type int $abp_rx2_dr
     *           RX2 DR (for ABP).
     *     @type int $abp_rx2_freq
     *           RX2 frequency (for ABP, Hz).
     *     @type array|\Google\Protobuf\Internal\MapField $tags
     *           Tags (user defined).
     *           These tags can be used to add additional information the the
     *           device-profile. These tags are exposed in all the integration events of
     *           devices using this device-profile.
     *     @type array|\Google\Protobuf\Internal\MapField $measurements
     *           Measurements.
     *           If defined, ChirpStack will visualize these metrics in the web-interface.
     *     @type bool $auto_detect_measurements
     *           Auto-detect measurements.
     *           If set to true, measurements will be automatically added based on the
     *           keys of the decoded payload. In cases where the decoded payload contains
     *           random keys in the data, you want to set this to false.
     *     @type string $region_config_id
     *           Region configuration ID.
     *           If set, devices will only use the associated region. If let blank, then
     *           devices will use all regions matching the selected common-name. Note
     *           that multiple region configurations can exist for the same common-name,
     *           e.g. to provide an 8 channel and 16 channel configuration for the US915
     *           band.
     *     @type bool $is_relay
     *           Device is a Relay device.
     *           Enable this in case the device is a Relay. A Relay device implements TS011
     *           and is able to relay data from relay capable devices.
     *           See for more information the TS011 specification.
     *     @type bool $is_relay_ed
     *           Device is a Relay end-device.
     *           Enable this in case the device is an end-device that can operate under a
     *           Relay. Please refer to the TS011 specification for more information.
     *     @type bool $relay_ed_relay_only
     *           End-device only accept data through relay.
     *           Only accept data for this device through a relay. This setting is useful
     *           for testing as in case of a test-setup, the end-device is usually within
     *           range of the gateway.
     *     @type bool $relay_enabled
     *           Relay must be enabled.
     *     @type int $relay_cad_periodicity
     *           Relay CAD periodicity.
     *     @type int $relay_default_channel_index
     *           Relay default channel index.
     *           Valid values are 0 and 1, please refer to the RP002 specification for
     *           the meaning of these values.
     *     @type int $relay_second_channel_freq
     *           Relay second channel frequency (Hz).
     *     @type int $relay_second_channel_dr
     *           Relay second channel DR.
     *     @type int $relay_second_channel_ack_offset
     *           Relay second channel ACK offset.
     *     @type int $relay_ed_activation_mode
     *           Relay end-device activation mode.
     *     @type int $relay_ed_smart_enable_level
     *           Relay end-device smart-enable level.
     *     @type int $relay_ed_back_off
     *           Relay end-device back-off (in case it does not receive WOR ACK frame).
     *           0 = Always send a LoRaWAN uplink
     *           1..63 = Send a LoRaWAN uplink after X WOR frames without a WOR ACK
     *     @type int $relay_ed_uplink_limit_bucket_size
     *           Relay end-device uplink limit bucket size.
     *           This field indicates the multiplier to determine the bucket size
     *           according to the following formula:
     *           BucketSize TOKEN = _reload_rate x _bucket_size
     *           Valid values (0 - 3):
     *             0 = 1
     *             1 = 2
     *             2 = 4
     *             3 = 12
     *     @type int $relay_ed_uplink_limit_reload_rate
     *           Relay end-device uplink limit reload rate.
     *           Valid values:
     *             * 0 - 62 = X tokens every hour
     *             * 63     = no limitation
     *     @type int $relay_join_req_limit_reload_rate
     *           Relay join-request limit reload rate.
     *           Valid values:
     *             * 0 - 126 = X tokens every hour
     *             * 127     = no limitation
     *     @type int $relay_notify_limit_reload_rate
     *           Relay notify limit reload rate.
     *           Valid values:
     *             * 0 - 126 = X tokens every hour
     *             * 127     = no limitation
     *     @type int $relay_global_uplink_limit_reload_rate
     *           Relay global uplink limit reload rate.
     *           Valid values:
     *             * 0 - 126 = X tokens every hour
     *             * 127     = no limitation
     *     @type int $relay_overall_limit_reload_rate
     *           Relay overall limit reload rate.
     *           Valid values:
     *             * 0 - 126 = X tokens every hour
     *             * 127     = no limitation
     *     @type int $relay_join_req_limit_bucket_size
     *           Relay join-request limit bucket size.
     *           This field indicates the multiplier to determine the bucket size
     *           according to the following formula:
     *           BucketSize TOKEN = _reload_rate x _bucket_size
     *           Valid values (0 - 3):
     *             0 = 1
     *             1 = 2
     *             2 = 4
     *             3 = 12
     *     @type int $relay_notify_limit_bucket_size
     *           Relay notify limit bucket size.
     *           This field indicates the multiplier to determine the bucket size
     *           according to the following formula:
     *           BucketSize TOKEN = _reload_rate x _bucket_size
     *           Valid values (0 - 3):
     *             0 = 1
     *             1 = 2
     *             2 = 4
     *             3 = 12
     *     @type int $relay_global_uplink_limit_bucket_size
     *           Relay globak uplink limit bucket size.
     *           This field indicates the multiplier to determine the bucket size
     *           according to the following formula:
     *           BucketSize TOKEN = _reload_rate x _bucket_size
     *           Valid values (0 - 3):
     *             0 = 1
     *             1 = 2
     *             2 = 4
     *             3 = 12
     *     @type int $relay_overall_limit_bucket_size
     *           Relay overall limit bucket size.
     *           This field indicates the multiplier to determine the bucket size
     *           according to the following formula:
     *           BucketSize TOKEN = _reload_rate x _bucket_size
     *           Valid values (0 - 3):
     *             0 = 1
     *             1 = 2
     *             2 = 4
     *             3 = 12
     *     @type bool $allow_roaming
     *           Allow roaming.
     *           If set to true, it means that the device is allowed to use roaming.
     *     @type int $rx1_delay
     *           RX1 Delay.
     *           This makes it possible to override the system RX1 Delay. Please note that
     *           this values only has effect in case it is higher than the system value.
     *           In other words, it can be used to increase the RX1 Delay but not to decrease
     *           it.
     *           Valid options are 1 - 15 (0 = always use system RX1 Delay).
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Chirpstack\Api\DeviceProfile::initOnce();
        parent::__construct($data);
    }

    /**
     * Device-profile ID (UUID).
     * Note: on create this will be automatically generated.
     *
     * Generated from protobuf field <code>string id = 1;</code>
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * Device-profile ID (UUID).
     * Note: on create this will be automatically generated.
     *
     * Generated from protobuf field <code>string id = 1;</code>
     * @param string $var
     * @return $this
     */
    public function setId($var)
    {
        GPBUtil::checkString($var, True);
        $this->id = $var;

        return $this;
    }

    /**
     * Tenant ID (UUID).
     *
     * Generated from protobuf field <code>string tenant_id = 2;</code>
     * @return string
     */
    public function getTenantId()
    {
        return $this->tenant_id;
    }

    /**
     * Tenant ID (UUID).
     *
     * Generated from protobuf field <code>string tenant_id = 2;</code>
     * @param string $var
     * @return $this
     */
    public function setTenantId($var)
    {
        GPBUtil::checkString($var, True);
        $this->tenant_id = $var;

        return $this;
    }

    /**
     * Name.
     *
     * Generated from protobuf field <code>string name = 3;</code>
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * Name.
     *
     * Generated from protobuf field <code>string name = 3;</code>
     * @param string $var
     * @return $this
     */
    public function setName($var)
    {
        GPBUtil::checkString($var, True);
        $this->name = $var;

        return $this;
    }

    /**
     * Description.
     *
     * Generated from protobuf field <code>string description = 26;</code>
     * @return string
     */
    public function getDescription()
    {
        return $this->description;
    }

    /**
     * Description.
     *
     * Generated from protobuf field <code>string description = 26;</code>
     * @param string $var
     * @return $this
     */
    public function setDescription($var)
    {
        GPBUtil::checkString($var, True);
        $this->description = $var;

        return $this;
    }

    /**
     * Region.
     *
     * Generated from protobuf field <code>.common.Region region = 4;</code>
     * @return int
     */
    public function getRegion()
    {
        return $this->region;
    }

    /**
     * Region.
     *
     * Generated from protobuf field <code>.common.Region region = 4;</code>
     * @param int $var
     * @return $this
     */
    public function setRegion($var)
    {
        GPBUtil::checkEnum($var, \Chirpstack\Common\Region::class);
        $this->region = $var;

        return $this;
    }

    /**
     * LoRaWAN mac-version.
     *
     * Generated from protobuf field <code>.common.MacVersion mac_version = 5;</code>
     * @return int
     */
    public function getMacVersion()
    {
        return $this->mac_version;
    }

    /**
     * LoRaWAN mac-version.
     *
     * Generated from protobuf field <code>.common.MacVersion mac_version = 5;</code>
     * @param int $var
     * @return $this
     */
    public function setMacVersion($var)
    {
        GPBUtil::checkEnum($var, \Chirpstack\Common\MacVersion::class);
        $this->mac_version = $var;

        return $this;
    }

    /**
     * Regional parameters revision.
     *
     * Generated from protobuf field <code>.common.RegParamsRevision reg_params_revision = 6;</code>
     * @return int
     */
    public function getRegParamsRevision()
    {
        return $this->reg_params_revision;
    }

    /**
     * Regional parameters revision.
     *
     * Generated from protobuf field <code>.common.RegParamsRevision reg_params_revision = 6;</code>
     * @param int $var
     * @return $this
     */
    public function setRegParamsRevision($var)
    {
        GPBUtil::checkEnum($var, \Chirpstack\Common\RegParamsRevision::class);
        $this->reg_params_revision = $var;

        return $this;
    }

    /**
     * ADR algorithm ID.
     *
     * Generated from protobuf field <code>string adr_algorithm_id = 7;</code>
     * @return string
     */
    public function getAdrAlgorithmId()
    {
        return $this->adr_algorithm_id;
    }

    /**
     * ADR algorithm ID.
     *
     * Generated from protobuf field <code>string adr_algorithm_id = 7;</code>
     * @param string $var
     * @return $this
     */
    public function setAdrAlgorithmId($var)
    {
        GPBUtil::checkString($var, True);
        $this->adr_algorithm_id = $var;

        return $this;
    }

    /**
     * Payload codec runtime.
     *
     * Generated from protobuf field <code>.api.CodecRuntime payload_codec_runtime = 8;</code>
     * @return int
     */
    public function getPayloadCodecRuntime()
    {
        return $this->payload_codec_runtime;
    }

    /**
     * Payload codec runtime.
     *
     * Generated from protobuf field <code>.api.CodecRuntime payload_codec_runtime = 8;</code>
     * @param int $var
     * @return $this
     */
    public function setPayloadCodecRuntime($var)
    {
        GPBUtil::checkEnum($var, \Chirpstack\Api\CodecRuntime::class);
        $this->payload_codec_runtime = $var;

        return $this;
    }

    /**
     * Payload codec script.
     *
     * Generated from protobuf field <code>string payload_codec_script = 9;</code>
     * @return string
     */
    public function getPayloadCodecScript()
    {
        return $this->payload_codec_script;
    }

    /**
     * Payload codec script.
     *
     * Generated from protobuf field <code>string payload_codec_script = 9;</code>
     * @param string $var
     * @return $this
     */
    public function setPayloadCodecScript($var)
    {
        GPBUtil::checkString($var, True);
        $this->payload_codec_script = $var;

        return $this;
    }

    /**
     * Flush queue on device activation.
     *
     * Generated from protobuf field <code>bool flush_queue_on_activate = 10;</code>
     * @return bool
     */
    public function getFlushQueueOnActivate()
    {
        return $this->flush_queue_on_activate;
    }

    /**
     * Flush queue on device activation.
     *
     * Generated from protobuf field <code>bool flush_queue_on_activate = 10;</code>
     * @param bool $var
     * @return $this
     */
    public function setFlushQueueOnActivate($var)
    {
        GPBUtil::checkBool($var);
        $this->flush_queue_on_activate = $var;

        return $this;
    }

    /**
     * Uplink interval (seconds).
     * This defines the expected uplink interval which the device uses for
     * communication. If the uplink interval has expired and no uplink has
     * been received, the device is considered inactive.
     *
     * Generated from protobuf field <code>uint32 uplink_interval = 11;</code>
     * @return int
     */
    public function getUplinkInterval()
    {
        return $this->uplink_interval;
    }

    /**
     * Uplink interval (seconds).
     * This defines the expected uplink interval which the device uses for
     * communication. If the uplink interval has expired and no uplink has
     * been received, the device is considered inactive.
     *
     * Generated from protobuf field <code>uint32 uplink_interval = 11;</code>
     * @param int $var
     * @return $this
     */
    public function setUplinkInterval($var)
    {
        GPBUtil::checkUint32($var);
        $this->uplink_interval = $var;

        return $this;
    }

    /**
     * Device-status request interval (times / day).
     * This defines the times per day that ChirpStack will request the
     * device-status from the device.
     *
     * Generated from protobuf field <code>uint32 device_status_req_interval = 12;</code>
     * @return int
     */
    public function getDeviceStatusReqInterval()
    {
        return $this->device_status_req_interval;
    }

    /**
     * Device-status request interval (times / day).
     * This defines the times per day that ChirpStack will request the
     * device-status from the device.
     *
     * Generated from protobuf field <code>uint32 device_status_req_interval = 12;</code>
     * @param int $var
     * @return $this
     */
    public function setDeviceStatusReqInterval($var)
    {
        GPBUtil::checkUint32($var);
        $this->device_status_req_interval = $var;

        return $this;
    }

    /**
     * Supports OTAA.
     *
     * Generated from protobuf field <code>bool supports_otaa = 13;</code>
     * @return bool
     */
    public function getSupportsOtaa()
    {
        return $this->supports_otaa;
    }

    /**
     * Supports OTAA.
     *
     * Generated from protobuf field <code>bool supports_otaa = 13;</code>
     * @param bool $var
     * @return $this
     */
    public function setSupportsOtaa($var)
    {
        GPBUtil::checkBool($var);
        $this->supports_otaa = $var;

        return $this;
    }

    /**
     * Supports Class B.
     *
     * Generated from protobuf field <code>bool supports_class_b = 14;</code>
     * @return bool
     */
    public function getSupportsClassB()
    {
        return $this->supports_class_b;
    }

    /**
     * Supports Class B.
     *
     * Generated from protobuf field <code>bool supports_class_b = 14;</code>
     * @param bool $var
     * @return $this
     */
    public function setSupportsClassB($var)
    {
        GPBUtil::checkBool($var);
        $this->supports_class_b = $var;

        return $this;
    }

    /**
     * Supports Class-C.
     *
     * Generated from protobuf field <code>bool supports_class_c = 15;</code>
     * @return bool
     */
    public function getSupportsClassC()
    {
        return $this->supports_class_c;
    }

    /**
     * Supports Class-C.
     *
     * Generated from protobuf field <code>bool supports_class_c = 15;</code>
     * @param bool $var
     * @return $this
     */
    public function setSupportsClassC($var)
    {
        GPBUtil::checkBool($var);
        $this->supports_class_c = $var;

        return $this;
    }

    /**
     * Class-B timeout (seconds).
     * This is the maximum time ChirpStack will wait to receive an acknowledgement
     * from the device (if requested).
     *
     * Generated from protobuf field <code>uint32 class_b_timeout = 16;</code>
     * @return int
     */
    public function getClassBTimeout()
    {
        return $this->class_b_timeout;
    }

    /**
     * Class-B timeout (seconds).
     * This is the maximum time ChirpStack will wait to receive an acknowledgement
     * from the device (if requested).
     *
     * Generated from protobuf field <code>uint32 class_b_timeout = 16;</code>
     * @param int $var
     * @return $this
     */
    public function setClassBTimeout($var)
    {
        GPBUtil::checkUint32($var);
        $this->class_b_timeout = $var;

        return $this;
    }

    /**
     * Class-B ping-slots per beacon period.
     * Valid options are: 0 - 7.
     * The actual number of ping-slots per beacon period equals to 2^k.
     *
     * Generated from protobuf field <code>uint32 class_b_ping_slot_nb_k = 17;</code>
     * @return int
     */
    public function getClassBPingSlotNbK()
    {
        return $this->class_b_ping_slot_nb_k;
    }

    /**
     * Class-B ping-slots per beacon period.
     * Valid options are: 0 - 7.
     * The actual number of ping-slots per beacon period equals to 2^k.
     *
     * Generated from protobuf field <code>uint32 class_b_ping_slot_nb_k = 17;</code>
     * @param int $var
     * @return $this
     */
    public function setClassBPingSlotNbK($var)
    {
        GPBUtil::checkUint32($var);
        $this->class_b_ping_slot_nb_k = $var;

        return $this;
    }

    /**
     * Class-B ping-slot DR.
     *
     * Generated from protobuf field <code>uint32 class_b_ping_slot_dr = 18;</code>
     * @return int
     */
    public function getClassBPingSlotDr()
    {
        return $this->class_b_ping_slot_dr;
    }

    /**
     * Class-B ping-slot DR.
     *
     * Generated from protobuf field <code>uint32 class_b_ping_slot_dr = 18;</code>
     * @param int $var
     * @return $this
     */
    public function setClassBPingSlotDr($var)
    {
        GPBUtil::checkUint32($var);
        $this->class_b_ping_slot_dr = $var;

        return $this;
    }

    /**
     * Class-B ping-slot freq (Hz).
     *
     * Generated from protobuf field <code>uint32 class_b_ping_slot_freq = 19;</code>
     * @return int
     */
    public function getClassBPingSlotFreq()
    {
        return $this->class_b_ping_slot_freq;
    }

    /**
     * Class-B ping-slot freq (Hz).
     *
     * Generated from protobuf field <code>uint32 class_b_ping_slot_freq = 19;</code>
     * @param int $var
     * @return $this
     */
    public function setClassBPingSlotFreq($var)
    {
        GPBUtil::checkUint32($var);
        $this->class_b_ping_slot_freq = $var;

        return $this;
    }

    /**
     * Class-C timeout (seconds).
     * This is the maximum time ChirpStack will wait to receive an acknowledgement
     * from the device (if requested).
     *
     * Generated from protobuf field <code>uint32 class_c_timeout = 20;</code>
     * @return int
     */
    public function getClassCTimeout()
    {
        return $this->class_c_timeout;
    }

    /**
     * Class-C timeout (seconds).
     * This is the maximum time ChirpStack will wait to receive an acknowledgement
     * from the device (if requested).
     *
     * Generated from protobuf field <code>uint32 class_c_timeout = 20;</code>
     * @param int $var
     * @return $this
     */
    public function setClassCTimeout($var)
    {
        GPBUtil::checkUint32($var);
        $this->class_c_timeout = $var;

        return $this;
    }

    /**
     * RX1 delay (for ABP).
     *
     * Generated from protobuf field <code>uint32 abp_rx1_delay = 21;</code>
     * @return int
     */
    public function getAbpRx1Delay()
    {
        return $this->abp_rx1_delay;
    }

    /**
     * RX1 delay (for ABP).
     *
     * Generated from protobuf field <code>uint32 abp_rx1_delay = 21;</code>
     * @param int $var
     * @return $this
     */
    public function setAbpRx1Delay($var)
    {
        GPBUtil::checkUint32($var);
        $this->abp_rx1_delay = $var;

        return $this;
    }

    /**
     * RX1 DR offset (for ABP).
     *
     * Generated from protobuf field <code>uint32 abp_rx1_dr_offset = 22;</code>
     * @return int
     */
    public function getAbpRx1DrOffset()
    {
        return $this->abp_rx1_dr_offset;
    }

    /**
     * RX1 DR offset (for ABP).
     *
     * Generated from protobuf field <code>uint32 abp_rx1_dr_offset = 22;</code>
     * @param int $var
     * @return $this
     */
    public function setAbpRx1DrOffset($var)
    {
        GPBUtil::checkUint32($var);
        $this->abp_rx1_dr_offset = $var;

        return $this;
    }

    /**
     * RX2 DR (for ABP).
     *
     * Generated from protobuf field <code>uint32 abp_rx2_dr = 23;</code>
     * @return int
     */
    public function getAbpRx2Dr()
    {
        return $this->abp_rx2_dr;
    }

    /**
     * RX2 DR (for ABP).
     *
     * Generated from protobuf field <code>uint32 abp_rx2_dr = 23;</code>
     * @param int $var
     * @return $this
     */
    public function setAbpRx2Dr($var)
    {
        GPBUtil::checkUint32($var);
        $this->abp_rx2_dr = $var;

        return $this;
    }

    /**
     * RX2 frequency (for ABP, Hz).
     *
     * Generated from protobuf field <code>uint32 abp_rx2_freq = 24;</code>
     * @return int
     */
    public function getAbpRx2Freq()
    {
        return $this->abp_rx2_freq;
    }

    /**
     * RX2 frequency (for ABP, Hz).
     *
     * Generated from protobuf field <code>uint32 abp_rx2_freq = 24;</code>
     * @param int $var
     * @return $this
     */
    public function setAbpRx2Freq($var)
    {
        GPBUtil::checkUint32($var);
        $this->abp_rx2_freq = $var;

        return $this;
    }

    /**
     * Tags (user defined).
     * These tags can be used to add additional information the the
     * device-profile. These tags are exposed in all the integration events of
     * devices using this device-profile.
     *
     * Generated from protobuf field <code>map<string, string> tags = 25;</code>
     * @return \Google\Protobuf\Internal\MapField
     */
    public function getTags()
    {
        return $this->tags;
    }

    /**
     * Tags (user defined).
     * These tags can be used to add additional information the the
     * device-profile. These tags are exposed in all the integration events of
     * devices using this device-profile.
     *
     * Generated from protobuf field <code>map<string, string> tags = 25;</code>
     * @param array|\Google\Protobuf\Internal\MapField $var
     * @return $this
     */
    public function setTags($var)
    {
        $arr = GPBUtil::checkMapField($var, \Google\Protobuf\Internal\GPBType::STRING, \Google\Protobuf\Internal\GPBType::STRING);
        $this->tags = $arr;

        return $this;
    }

    /**
     * Measurements.
     * If defined, ChirpStack will visualize these metrics in the web-interface.
     *
     * Generated from protobuf field <code>map<string, .api.Measurement> measurements = 27;</code>
     * @return \Google\Protobuf\Internal\MapField
     */
    public function getMeasurements()
    {
        return $this->measurements;
    }

    /**
     * Measurements.
     * If defined, ChirpStack will visualize these metrics in the web-interface.
     *
     * Generated from protobuf field <code>map<string, .api.Measurement> measurements = 27;</code>
     * @param array|\Google\Protobuf\Internal\MapField $var
     * @return $this
     */
    public function setMeasurements($var)
    {
        $arr = GPBUtil::checkMapField($var, \Google\Protobuf\Internal\GPBType::STRING, \Google\Protobuf\Internal\GPBType::MESSAGE, \Chirpstack\Api\Measurement::class);
        $this->measurements = $arr;

        return $this;
    }

    /**
     * Auto-detect measurements.
     * If set to true, measurements will be automatically added based on the
     * keys of the decoded payload. In cases where the decoded payload contains
     * random keys in the data, you want to set this to false.
     *
     * Generated from protobuf field <code>bool auto_detect_measurements = 28;</code>
     * @return bool
     */
    public function getAutoDetectMeasurements()
    {
        return $this->auto_detect_measurements;
    }

    /**
     * Auto-detect measurements.
     * If set to true, measurements will be automatically added based on the
     * keys of the decoded payload. In cases where the decoded payload contains
     * random keys in the data, you want to set this to false.
     *
     * Generated from protobuf field <code>bool auto_detect_measurements = 28;</code>
     * @param bool $var
     * @return $this
     */
    public function setAutoDetectMeasurements($var)
    {
        GPBUtil::checkBool($var);
        $this->auto_detect_measurements = $var;

        return $this;
    }

    /**
     * Region configuration ID.
     * If set, devices will only use the associated region. If let blank, then
     * devices will use all regions matching the selected common-name. Note
     * that multiple region configurations can exist for the same common-name,
     * e.g. to provide an 8 channel and 16 channel configuration for the US915
     * band.
     *
     * Generated from protobuf field <code>string region_config_id = 29;</code>
     * @return string
     */
    public function getRegionConfigId()
    {
        return $this->region_config_id;
    }

    /**
     * Region configuration ID.
     * If set, devices will only use the associated region. If let blank, then
     * devices will use all regions matching the selected common-name. Note
     * that multiple region configurations can exist for the same common-name,
     * e.g. to provide an 8 channel and 16 channel configuration for the US915
     * band.
     *
     * Generated from protobuf field <code>string region_config_id = 29;</code>
     * @param string $var
     * @return $this
     */
    public function setRegionConfigId($var)
    {
        GPBUtil::checkString($var, True);
        $this->region_config_id = $var;

        return $this;
    }

    /**
     * Device is a Relay device.
     * Enable this in case the device is a Relay. A Relay device implements TS011
     * and is able to relay data from relay capable devices.
     * See for more information the TS011 specification.
     *
     * Generated from protobuf field <code>bool is_relay = 30;</code>
     * @return bool
     */
    public function getIsRelay()
    {
        return $this->is_relay;
    }

    /**
     * Device is a Relay device.
     * Enable this in case the device is a Relay. A Relay device implements TS011
     * and is able to relay data from relay capable devices.
     * See for more information the TS011 specification.
     *
     * Generated from protobuf field <code>bool is_relay = 30;</code>
     * @param bool $var
     * @return $this
     */
    public function setIsRelay($var)
    {
        GPBUtil::checkBool($var);
        $this->is_relay = $var;

        return $this;
    }

    /**
     * Device is a Relay end-device.
     * Enable this in case the device is an end-device that can operate under a
     * Relay. Please refer to the TS011 specification for more information.
     *
     * Generated from protobuf field <code>bool is_relay_ed = 31;</code>
     * @return bool
     */
    public function getIsRelayEd()
    {
        return $this->is_relay_ed;
    }

    /**
     * Device is a Relay end-device.
     * Enable this in case the device is an end-device that can operate under a
     * Relay. Please refer to the TS011 specification for more information.
     *
     * Generated from protobuf field <code>bool is_relay_ed = 31;</code>
     * @param bool $var
     * @return $this
     */
    public function setIsRelayEd($var)
    {
        GPBUtil::checkBool($var);
        $this->is_relay_ed = $var;

        return $this;
    }

    /**
     * End-device only accept data through relay.
     * Only accept data for this device through a relay. This setting is useful
     * for testing as in case of a test-setup, the end-device is usually within
     * range of the gateway.
     *
     * Generated from protobuf field <code>bool relay_ed_relay_only = 32;</code>
     * @return bool
     */
    public function getRelayEdRelayOnly()
    {
        return $this->relay_ed_relay_only;
    }

    /**
     * End-device only accept data through relay.
     * Only accept data for this device through a relay. This setting is useful
     * for testing as in case of a test-setup, the end-device is usually within
     * range of the gateway.
     *
     * Generated from protobuf field <code>bool relay_ed_relay_only = 32;</code>
     * @param bool $var
     * @return $this
     */
    public function setRelayEdRelayOnly($var)
    {
        GPBUtil::checkBool($var);
        $this->relay_ed_relay_only = $var;

        return $this;
    }

    /**
     * Relay must be enabled.
     *
     * Generated from protobuf field <code>bool relay_enabled = 33;</code>
     * @return bool
     */
    public function getRelayEnabled()
    {
        return $this->relay_enabled;
    }

    /**
     * Relay must be enabled.
     *
     * Generated from protobuf field <code>bool relay_enabled = 33;</code>
     * @param bool $var
     * @return $this
     */
    public function setRelayEnabled($var)
    {
        GPBUtil::checkBool($var);
        $this->relay_enabled = $var;

        return $this;
    }

    /**
     * Relay CAD periodicity.
     *
     * Generated from protobuf field <code>.api.CadPeriodicity relay_cad_periodicity = 34;</code>
     * @return int
     */
    public function getRelayCadPeriodicity()
    {
        return $this->relay_cad_periodicity;
    }

    /**
     * Relay CAD periodicity.
     *
     * Generated from protobuf field <code>.api.CadPeriodicity relay_cad_periodicity = 34;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayCadPeriodicity($var)
    {
        GPBUtil::checkEnum($var, \Chirpstack\Api\CadPeriodicity::class);
        $this->relay_cad_periodicity = $var;

        return $this;
    }

    /**
     * Relay default channel index.
     * Valid values are 0 and 1, please refer to the RP002 specification for
     * the meaning of these values.
     *
     * Generated from protobuf field <code>uint32 relay_default_channel_index = 35;</code>
     * @return int
     */
    public function getRelayDefaultChannelIndex()
    {
        return $this->relay_default_channel_index;
    }

    /**
     * Relay default channel index.
     * Valid values are 0 and 1, please refer to the RP002 specification for
     * the meaning of these values.
     *
     * Generated from protobuf field <code>uint32 relay_default_channel_index = 35;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayDefaultChannelIndex($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_default_channel_index = $var;

        return $this;
    }

    /**
     * Relay second channel frequency (Hz).
     *
     * Generated from protobuf field <code>uint32 relay_second_channel_freq = 36;</code>
     * @return int
     */
    public function getRelaySecondChannelFreq()
    {
        return $this->relay_second_channel_freq;
    }

    /**
     * Relay second channel frequency (Hz).
     *
     * Generated from protobuf field <code>uint32 relay_second_channel_freq = 36;</code>
     * @param int $var
     * @return $this
     */
    public function setRelaySecondChannelFreq($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_second_channel_freq = $var;

        return $this;
    }

    /**
     * Relay second channel DR.
     *
     * Generated from protobuf field <code>uint32 relay_second_channel_dr = 37;</code>
     * @return int
     */
    public function getRelaySecondChannelDr()
    {
        return $this->relay_second_channel_dr;
    }

    /**
     * Relay second channel DR.
     *
     * Generated from protobuf field <code>uint32 relay_second_channel_dr = 37;</code>
     * @param int $var
     * @return $this
     */
    public function setRelaySecondChannelDr($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_second_channel_dr = $var;

        return $this;
    }

    /**
     * Relay second channel ACK offset.
     *
     * Generated from protobuf field <code>.api.SecondChAckOffset relay_second_channel_ack_offset = 38;</code>
     * @return int
     */
    public function getRelaySecondChannelAckOffset()
    {
        return $this->relay_second_channel_ack_offset;
    }

    /**
     * Relay second channel ACK offset.
     *
     * Generated from protobuf field <code>.api.SecondChAckOffset relay_second_channel_ack_offset = 38;</code>
     * @param int $var
     * @return $this
     */
    public function setRelaySecondChannelAckOffset($var)
    {
        GPBUtil::checkEnum($var, \Chirpstack\Api\SecondChAckOffset::class);
        $this->relay_second_channel_ack_offset = $var;

        return $this;
    }

    /**
     * Relay end-device activation mode.
     *
     * Generated from protobuf field <code>.api.RelayModeActivation relay_ed_activation_mode = 39;</code>
     * @return int
     */
    public function getRelayEdActivationMode()
    {
        return $this->relay_ed_activation_mode;
    }

    /**
     * Relay end-device activation mode.
     *
     * Generated from protobuf field <code>.api.RelayModeActivation relay_ed_activation_mode = 39;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayEdActivationMode($var)
    {
        GPBUtil::checkEnum($var, \Chirpstack\Api\RelayModeActivation::class);
        $this->relay_ed_activation_mode = $var;

        return $this;
    }

    /**
     * Relay end-device smart-enable level.
     *
     * Generated from protobuf field <code>uint32 relay_ed_smart_enable_level = 40;</code>
     * @return int
     */
    public function getRelayEdSmartEnableLevel()
    {
        return $this->relay_ed_smart_enable_level;
    }

    /**
     * Relay end-device smart-enable level.
     *
     * Generated from protobuf field <code>uint32 relay_ed_smart_enable_level = 40;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayEdSmartEnableLevel($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_ed_smart_enable_level = $var;

        return $this;
    }

    /**
     * Relay end-device back-off (in case it does not receive WOR ACK frame).
     * 0 = Always send a LoRaWAN uplink
     * 1..63 = Send a LoRaWAN uplink after X WOR frames without a WOR ACK
     *
     * Generated from protobuf field <code>uint32 relay_ed_back_off = 41;</code>
     * @return int
     */
    public function getRelayEdBackOff()
    {
        return $this->relay_ed_back_off;
    }

    /**
     * Relay end-device back-off (in case it does not receive WOR ACK frame).
     * 0 = Always send a LoRaWAN uplink
     * 1..63 = Send a LoRaWAN uplink after X WOR frames without a WOR ACK
     *
     * Generated from protobuf field <code>uint32 relay_ed_back_off = 41;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayEdBackOff($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_ed_back_off = $var;

        return $this;
    }

    /**
     * Relay end-device uplink limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_ed_uplink_limit_bucket_size = 42;</code>
     * @return int
     */
    public function getRelayEdUplinkLimitBucketSize()
    {
        return $this->relay_ed_uplink_limit_bucket_size;
    }

    /**
     * Relay end-device uplink limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_ed_uplink_limit_bucket_size = 42;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayEdUplinkLimitBucketSize($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_ed_uplink_limit_bucket_size = $var;

        return $this;
    }

    /**
     * Relay end-device uplink limit reload rate.
     * Valid values:
     *   * 0 - 62 = X tokens every hour
     *   * 63     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_ed_uplink_limit_reload_rate = 43;</code>
     * @return int
     */
    public function getRelayEdUplinkLimitReloadRate()
    {
        return $this->relay_ed_uplink_limit_reload_rate;
    }

    /**
     * Relay end-device uplink limit reload rate.
     * Valid values:
     *   * 0 - 62 = X tokens every hour
     *   * 63     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_ed_uplink_limit_reload_rate = 43;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayEdUplinkLimitReloadRate($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_ed_uplink_limit_reload_rate = $var;

        return $this;
    }

    /**
     * Relay join-request limit reload rate.
     * Valid values:
     *   * 0 - 126 = X tokens every hour
     *   * 127     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_join_req_limit_reload_rate = 44;</code>
     * @return int
     */
    public function getRelayJoinReqLimitReloadRate()
    {
        return $this->relay_join_req_limit_reload_rate;
    }

    /**
     * Relay join-request limit reload rate.
     * Valid values:
     *   * 0 - 126 = X tokens every hour
     *   * 127     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_join_req_limit_reload_rate = 44;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayJoinReqLimitReloadRate($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_join_req_limit_reload_rate = $var;

        return $this;
    }

    /**
     * Relay notify limit reload rate.
     * Valid values:
     *   * 0 - 126 = X tokens every hour
     *   * 127     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_notify_limit_reload_rate = 45;</code>
     * @return int
     */
    public function getRelayNotifyLimitReloadRate()
    {
        return $this->relay_notify_limit_reload_rate;
    }

    /**
     * Relay notify limit reload rate.
     * Valid values:
     *   * 0 - 126 = X tokens every hour
     *   * 127     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_notify_limit_reload_rate = 45;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayNotifyLimitReloadRate($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_notify_limit_reload_rate = $var;

        return $this;
    }

    /**
     * Relay global uplink limit reload rate.
     * Valid values:
     *   * 0 - 126 = X tokens every hour
     *   * 127     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_global_uplink_limit_reload_rate = 46;</code>
     * @return int
     */
    public function getRelayGlobalUplinkLimitReloadRate()
    {
        return $this->relay_global_uplink_limit_reload_rate;
    }

    /**
     * Relay global uplink limit reload rate.
     * Valid values:
     *   * 0 - 126 = X tokens every hour
     *   * 127     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_global_uplink_limit_reload_rate = 46;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayGlobalUplinkLimitReloadRate($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_global_uplink_limit_reload_rate = $var;

        return $this;
    }

    /**
     * Relay overall limit reload rate.
     * Valid values:
     *   * 0 - 126 = X tokens every hour
     *   * 127     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_overall_limit_reload_rate = 47;</code>
     * @return int
     */
    public function getRelayOverallLimitReloadRate()
    {
        return $this->relay_overall_limit_reload_rate;
    }

    /**
     * Relay overall limit reload rate.
     * Valid values:
     *   * 0 - 126 = X tokens every hour
     *   * 127     = no limitation
     *
     * Generated from protobuf field <code>uint32 relay_overall_limit_reload_rate = 47;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayOverallLimitReloadRate($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_overall_limit_reload_rate = $var;

        return $this;
    }

    /**
     * Relay join-request limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_join_req_limit_bucket_size = 48;</code>
     * @return int
     */
    public function getRelayJoinReqLimitBucketSize()
    {
        return $this->relay_join_req_limit_bucket_size;
    }

    /**
     * Relay join-request limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_join_req_limit_bucket_size = 48;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayJoinReqLimitBucketSize($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_join_req_limit_bucket_size = $var;

        return $this;
    }

    /**
     * Relay notify limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_notify_limit_bucket_size = 49;</code>
     * @return int
     */
    public function getRelayNotifyLimitBucketSize()
    {
        return $this->relay_notify_limit_bucket_size;
    }

    /**
     * Relay notify limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_notify_limit_bucket_size = 49;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayNotifyLimitBucketSize($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_notify_limit_bucket_size = $var;

        return $this;
    }

    /**
     * Relay globak uplink limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_global_uplink_limit_bucket_size = 50;</code>
     * @return int
     */
    public function getRelayGlobalUplinkLimitBucketSize()
    {
        return $this->relay_global_uplink_limit_bucket_size;
    }

    /**
     * Relay globak uplink limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_global_uplink_limit_bucket_size = 50;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayGlobalUplinkLimitBucketSize($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_global_uplink_limit_bucket_size = $var;

        return $this;
    }

    /**
     * Relay overall limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_overall_limit_bucket_size = 51;</code>
     * @return int
     */
    public function getRelayOverallLimitBucketSize()
    {
        return $this->relay_overall_limit_bucket_size;
    }

    /**
     * Relay overall limit bucket size.
     * This field indicates the multiplier to determine the bucket size
     * according to the following formula:
     * BucketSize TOKEN = _reload_rate x _bucket_size
     * Valid values (0 - 3):
     *   0 = 1
     *   1 = 2
     *   2 = 4
     *   3 = 12
     *
     * Generated from protobuf field <code>uint32 relay_overall_limit_bucket_size = 51;</code>
     * @param int $var
     * @return $this
     */
    public function setRelayOverallLimitBucketSize($var)
    {
        GPBUtil::checkUint32($var);
        $this->relay_overall_limit_bucket_size = $var;

        return $this;
    }

    /**
     * Allow roaming.
     * If set to true, it means that the device is allowed to use roaming.
     *
     * Generated from protobuf field <code>bool allow_roaming = 52;</code>
     * @return bool
     */
    public function getAllowRoaming()
    {
        return $this->allow_roaming;
    }

    /**
     * Allow roaming.
     * If set to true, it means that the device is allowed to use roaming.
     *
     * Generated from protobuf field <code>bool allow_roaming = 52;</code>
     * @param bool $var
     * @return $this
     */
    public function setAllowRoaming($var)
    {
        GPBUtil::checkBool($var);
        $this->allow_roaming = $var;

        return $this;
    }

    /**
     * RX1 Delay.
     * This makes it possible to override the system RX1 Delay. Please note that
     * this values only has effect in case it is higher than the system value.
     * In other words, it can be used to increase the RX1 Delay but not to decrease
     * it.
     * Valid options are 1 - 15 (0 = always use system RX1 Delay).
     *
     * Generated from protobuf field <code>uint32 rx1_delay = 53;</code>
     * @return int
     */
    public function getRx1Delay()
    {
        return $this->rx1_delay;
    }

    /**
     * RX1 Delay.
     * This makes it possible to override the system RX1 Delay. Please note that
     * this values only has effect in case it is higher than the system value.
     * In other words, it can be used to increase the RX1 Delay but not to decrease
     * it.
     * Valid options are 1 - 15 (0 = always use system RX1 Delay).
     *
     * Generated from protobuf field <code>uint32 rx1_delay = 53;</code>
     * @param int $var
     * @return $this
     */
    public function setRx1Delay($var)
    {
        GPBUtil::checkUint32($var);
        $this->rx1_delay = $var;

        return $this;
    }

}

