<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: as/external/api/profiles.proto

namespace Api;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Generated from protobuf message <code>api.DeviceProfile</code>
 */
class DeviceProfile extends \Google\Protobuf\Internal\Message
{
    /**
     * Device-profile ID (UUID string).
     *
     * Generated from protobuf field <code>string id = 1;</code>
     */
    protected $id = '';
    /**
     * Device-profile name.
     *
     * Generated from protobuf field <code>string name = 21;</code>
     */
    protected $name = '';
    /**
     * Organization ID to which the service-profile is assigned.
     *
     * Generated from protobuf field <code>int64 organization_id = 22 [json_name = "organizationID"];</code>
     */
    protected $organization_id = 0;
    /**
     * Network-server ID on which the service-profile is provisioned.
     *
     * Generated from protobuf field <code>int64 network_server_id = 23 [json_name = "networkServerID"];</code>
     */
    protected $network_server_id = 0;
    /**
     * End-Device supports Class B.
     *
     * Generated from protobuf field <code>bool supports_class_b = 2;</code>
     */
    protected $supports_class_b = false;
    /**
     * Maximum delay for the End-Device to answer a MAC request or a confirmed DL frame (mandatory if class B mode supported).
     *
     * Generated from protobuf field <code>uint32 class_b_timeout = 3;</code>
     */
    protected $class_b_timeout = 0;
    /**
     * Mandatory if class B mode supported.
     *
     * Generated from protobuf field <code>uint32 ping_slot_period = 4;</code>
     */
    protected $ping_slot_period = 0;
    /**
     * Mandatory if class B mode supported.
     *
     * Generated from protobuf field <code>uint32 ping_slot_dr = 5 [json_name = "pingSlotDR"];</code>
     */
    protected $ping_slot_dr = 0;
    /**
     * Mandatory if class B mode supported.
     *
     * Generated from protobuf field <code>uint32 ping_slot_freq = 6;</code>
     */
    protected $ping_slot_freq = 0;
    /**
     * End-Device supports Class C.
     *
     * Generated from protobuf field <code>bool supports_class_c = 7;</code>
     */
    protected $supports_class_c = false;
    /**
     * Maximum delay for the End-Device to answer a MAC request or a confirmed DL frame (mandatory if class C mode supported).
     *
     * Generated from protobuf field <code>uint32 class_c_timeout = 8;</code>
     */
    protected $class_c_timeout = 0;
    /**
     * Version of the LoRaWAN supported by the End-Device.
     *
     * Generated from protobuf field <code>string mac_version = 9;</code>
     */
    protected $mac_version = '';
    /**
     * Revision of the Regional Parameters document supported by the End-Device.
     *
     * Generated from protobuf field <code>string reg_params_revision = 10;</code>
     */
    protected $reg_params_revision = '';
    /**
     * Class A RX1 delay (mandatory for ABP).
     *
     * Generated from protobuf field <code>uint32 rx_delay_1 = 11;</code>
     */
    protected $rx_delay_1 = 0;
    /**
     * RX1 data rate offset (mandatory for ABP).
     *
     * Generated from protobuf field <code>uint32 rx_dr_offset_1 = 12 [json_name = "rxDROffset1"];</code>
     */
    protected $rx_dr_offset_1 = 0;
    /**
     * RX2 data rate (mandatory for ABP).
     *
     * Generated from protobuf field <code>uint32 rx_datarate_2 = 13 [json_name = "rxDataRate2"];</code>
     */
    protected $rx_datarate_2 = 0;
    /**
     * RX2 channel frequency (mandatory for ABP).
     *
     * Generated from protobuf field <code>uint32 rx_freq_2 = 14;</code>
     */
    protected $rx_freq_2 = 0;
    /**
     * List of factory-preset frequencies (mandatory for ABP).
     *
     * Generated from protobuf field <code>repeated uint32 factory_preset_freqs = 15;</code>
     */
    private $factory_preset_freqs;
    /**
     * Maximum EIRP supported by the End-Device.
     *
     * Generated from protobuf field <code>uint32 max_eirp = 16 [json_name = "maxEIRP"];</code>
     */
    protected $max_eirp = 0;
    /**
     * Maximum duty cycle supported by the End-Device.
     *
     * Generated from protobuf field <code>uint32 max_duty_cycle = 17;</code>
     */
    protected $max_duty_cycle = 0;
    /**
     * End-Device supports Join (OTAA) or not (ABP).
     *
     * Generated from protobuf field <code>bool supports_join = 18;</code>
     */
    protected $supports_join = false;
    /**
     * RF region name.
     *
     * Generated from protobuf field <code>string rf_region = 19;</code>
     */
    protected $rf_region = '';
    /**
     * End-Device uses 32bit FCnt (mandatory for LoRaWAN 1.0 End-Device).
     *
     * Generated from protobuf field <code>bool supports_32bit_f_cnt = 20 [json_name = "supports32BitFCnt"];</code>
     */
    protected $supports_32bit_f_cnt = false;
    /**
     * Payload codec.
     * Leave blank to disable the codec feature.
     *
     * Generated from protobuf field <code>string payload_codec = 24;</code>
     */
    protected $payload_codec = '';
    /**
     * Payload encoder script.
     * Depending the codec, it is possible to provide a script which implements
     * the encoder function.
     *
     * Generated from protobuf field <code>string payload_encoder_script = 25;</code>
     */
    protected $payload_encoder_script = '';
    /**
     * Payload decoder script.
     * Depending the codec, it is possible to provide a script which implements
     * the decoder function.
     *
     * Generated from protobuf field <code>string payload_decoder_script = 26;</code>
     */
    protected $payload_decoder_script = '';
    /**
     * Geolocation buffer TTL (in seconds).
     * When > 0, uplink RX meta-data will be stored in a buffer so that
     * the meta-data of multiple uplinks can be used for geolocation.
     *
     * Generated from protobuf field <code>uint32 geoloc_buffer_ttl = 27 [json_name = "geolocBufferTTL"];</code>
     */
    protected $geoloc_buffer_ttl = 0;
    /**
     * Geolocation minimum buffer size.
     * When > 0, geolocation will only be performed when the buffer has
     * at least the given size.
     *
     * Generated from protobuf field <code>uint32 geoloc_min_buffer_size = 28;</code>
     */
    protected $geoloc_min_buffer_size = 0;
    /**
     * User defined tags.
     *
     * Generated from protobuf field <code>map<string, string> tags = 29;</code>
     */
    private $tags;
    /**
     * Uplink interval.
     * This defines the expected uplink interval which the device uses for
     * communication. When the uplink interval has expired and no uplink has
     * been received, the device is considered inactive.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration uplink_interval = 30;</code>
     */
    protected $uplink_interval = null;
    /**
     * ADR algorithm ID.
     * In case this is left blank, or is configured to a non-existing ADR
     * algorithm (plugin), then it falls back to 'default'.
     *
     * Generated from protobuf field <code>string adr_algorithm_id = 31 [json_name = "adrAlgorithmID"];</code>
     */
    protected $adr_algorithm_id = '';

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $id
     *           Device-profile ID (UUID string).
     *     @type string $name
     *           Device-profile name.
     *     @type int|string $organization_id
     *           Organization ID to which the service-profile is assigned.
     *     @type int|string $network_server_id
     *           Network-server ID on which the service-profile is provisioned.
     *     @type bool $supports_class_b
     *           End-Device supports Class B.
     *     @type int $class_b_timeout
     *           Maximum delay for the End-Device to answer a MAC request or a confirmed DL frame (mandatory if class B mode supported).
     *     @type int $ping_slot_period
     *           Mandatory if class B mode supported.
     *     @type int $ping_slot_dr
     *           Mandatory if class B mode supported.
     *     @type int $ping_slot_freq
     *           Mandatory if class B mode supported.
     *     @type bool $supports_class_c
     *           End-Device supports Class C.
     *     @type int $class_c_timeout
     *           Maximum delay for the End-Device to answer a MAC request or a confirmed DL frame (mandatory if class C mode supported).
     *     @type string $mac_version
     *           Version of the LoRaWAN supported by the End-Device.
     *     @type string $reg_params_revision
     *           Revision of the Regional Parameters document supported by the End-Device.
     *     @type int $rx_delay_1
     *           Class A RX1 delay (mandatory for ABP).
     *     @type int $rx_dr_offset_1
     *           RX1 data rate offset (mandatory for ABP).
     *     @type int $rx_datarate_2
     *           RX2 data rate (mandatory for ABP).
     *     @type int $rx_freq_2
     *           RX2 channel frequency (mandatory for ABP).
     *     @type array<int>|\Google\Protobuf\Internal\RepeatedField $factory_preset_freqs
     *           List of factory-preset frequencies (mandatory for ABP).
     *     @type int $max_eirp
     *           Maximum EIRP supported by the End-Device.
     *     @type int $max_duty_cycle
     *           Maximum duty cycle supported by the End-Device.
     *     @type bool $supports_join
     *           End-Device supports Join (OTAA) or not (ABP).
     *     @type string $rf_region
     *           RF region name.
     *     @type bool $supports_32bit_f_cnt
     *           End-Device uses 32bit FCnt (mandatory for LoRaWAN 1.0 End-Device).
     *     @type string $payload_codec
     *           Payload codec.
     *           Leave blank to disable the codec feature.
     *     @type string $payload_encoder_script
     *           Payload encoder script.
     *           Depending the codec, it is possible to provide a script which implements
     *           the encoder function.
     *     @type string $payload_decoder_script
     *           Payload decoder script.
     *           Depending the codec, it is possible to provide a script which implements
     *           the decoder function.
     *     @type int $geoloc_buffer_ttl
     *           Geolocation buffer TTL (in seconds).
     *           When > 0, uplink RX meta-data will be stored in a buffer so that
     *           the meta-data of multiple uplinks can be used for geolocation.
     *     @type int $geoloc_min_buffer_size
     *           Geolocation minimum buffer size.
     *           When > 0, geolocation will only be performed when the buffer has
     *           at least the given size.
     *     @type array|\Google\Protobuf\Internal\MapField $tags
     *           User defined tags.
     *     @type \Google\Protobuf\Duration $uplink_interval
     *           Uplink interval.
     *           This defines the expected uplink interval which the device uses for
     *           communication. When the uplink interval has expired and no uplink has
     *           been received, the device is considered inactive.
     *     @type string $adr_algorithm_id
     *           ADR algorithm ID.
     *           In case this is left blank, or is configured to a non-existing ADR
     *           algorithm (plugin), then it falls back to 'default'.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\PBAs\External\Api\Profiles::initOnce();
        parent::__construct($data);
    }

    /**
     * Device-profile ID (UUID string).
     *
     * Generated from protobuf field <code>string id = 1;</code>
     * @return string
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * Device-profile ID (UUID string).
     *
     * Generated from protobuf field <code>string id = 1;</code>
     * @param string $var
     * @return $this
     */
    public function setId($var)
    {
        GPBUtil::checkString($var, True);
        $this->id = $var;

        return $this;
    }

    /**
     * Device-profile name.
     *
     * Generated from protobuf field <code>string name = 21;</code>
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }

    /**
     * Device-profile name.
     *
     * Generated from protobuf field <code>string name = 21;</code>
     * @param string $var
     * @return $this
     */
    public function setName($var)
    {
        GPBUtil::checkString($var, True);
        $this->name = $var;

        return $this;
    }

    /**
     * Organization ID to which the service-profile is assigned.
     *
     * Generated from protobuf field <code>int64 organization_id = 22 [json_name = "organizationID"];</code>
     * @return int|string
     */
    public function getOrganizationId()
    {
        return $this->organization_id;
    }

    /**
     * Organization ID to which the service-profile is assigned.
     *
     * Generated from protobuf field <code>int64 organization_id = 22 [json_name = "organizationID"];</code>
     * @param int|string $var
     * @return $this
     */
    public function setOrganizationId($var)
    {
        GPBUtil::checkInt64($var);
        $this->organization_id = $var;

        return $this;
    }

    /**
     * Network-server ID on which the service-profile is provisioned.
     *
     * Generated from protobuf field <code>int64 network_server_id = 23 [json_name = "networkServerID"];</code>
     * @return int|string
     */
    public function getNetworkServerId()
    {
        return $this->network_server_id;
    }

    /**
     * Network-server ID on which the service-profile is provisioned.
     *
     * Generated from protobuf field <code>int64 network_server_id = 23 [json_name = "networkServerID"];</code>
     * @param int|string $var
     * @return $this
     */
    public function setNetworkServerId($var)
    {
        GPBUtil::checkInt64($var);
        $this->network_server_id = $var;

        return $this;
    }

    /**
     * End-Device supports Class B.
     *
     * Generated from protobuf field <code>bool supports_class_b = 2;</code>
     * @return bool
     */
    public function getSupportsClassB()
    {
        return $this->supports_class_b;
    }

    /**
     * End-Device supports Class B.
     *
     * Generated from protobuf field <code>bool supports_class_b = 2;</code>
     * @param bool $var
     * @return $this
     */
    public function setSupportsClassB($var)
    {
        GPBUtil::checkBool($var);
        $this->supports_class_b = $var;

        return $this;
    }

    /**
     * Maximum delay for the End-Device to answer a MAC request or a confirmed DL frame (mandatory if class B mode supported).
     *
     * Generated from protobuf field <code>uint32 class_b_timeout = 3;</code>
     * @return int
     */
    public function getClassBTimeout()
    {
        return $this->class_b_timeout;
    }

    /**
     * Maximum delay for the End-Device to answer a MAC request or a confirmed DL frame (mandatory if class B mode supported).
     *
     * Generated from protobuf field <code>uint32 class_b_timeout = 3;</code>
     * @param int $var
     * @return $this
     */
    public function setClassBTimeout($var)
    {
        GPBUtil::checkUint32($var);
        $this->class_b_timeout = $var;

        return $this;
    }

    /**
     * Mandatory if class B mode supported.
     *
     * Generated from protobuf field <code>uint32 ping_slot_period = 4;</code>
     * @return int
     */
    public function getPingSlotPeriod()
    {
        return $this->ping_slot_period;
    }

    /**
     * Mandatory if class B mode supported.
     *
     * Generated from protobuf field <code>uint32 ping_slot_period = 4;</code>
     * @param int $var
     * @return $this
     */
    public function setPingSlotPeriod($var)
    {
        GPBUtil::checkUint32($var);
        $this->ping_slot_period = $var;

        return $this;
    }

    /**
     * Mandatory if class B mode supported.
     *
     * Generated from protobuf field <code>uint32 ping_slot_dr = 5 [json_name = "pingSlotDR"];</code>
     * @return int
     */
    public function getPingSlotDr()
    {
        return $this->ping_slot_dr;
    }

    /**
     * Mandatory if class B mode supported.
     *
     * Generated from protobuf field <code>uint32 ping_slot_dr = 5 [json_name = "pingSlotDR"];</code>
     * @param int $var
     * @return $this
     */
    public function setPingSlotDr($var)
    {
        GPBUtil::checkUint32($var);
        $this->ping_slot_dr = $var;

        return $this;
    }

    /**
     * Mandatory if class B mode supported.
     *
     * Generated from protobuf field <code>uint32 ping_slot_freq = 6;</code>
     * @return int
     */
    public function getPingSlotFreq()
    {
        return $this->ping_slot_freq;
    }

    /**
     * Mandatory if class B mode supported.
     *
     * Generated from protobuf field <code>uint32 ping_slot_freq = 6;</code>
     * @param int $var
     * @return $this
     */
    public function setPingSlotFreq($var)
    {
        GPBUtil::checkUint32($var);
        $this->ping_slot_freq = $var;

        return $this;
    }

    /**
     * End-Device supports Class C.
     *
     * Generated from protobuf field <code>bool supports_class_c = 7;</code>
     * @return bool
     */
    public function getSupportsClassC()
    {
        return $this->supports_class_c;
    }

    /**
     * End-Device supports Class C.
     *
     * Generated from protobuf field <code>bool supports_class_c = 7;</code>
     * @param bool $var
     * @return $this
     */
    public function setSupportsClassC($var)
    {
        GPBUtil::checkBool($var);
        $this->supports_class_c = $var;

        return $this;
    }

    /**
     * Maximum delay for the End-Device to answer a MAC request or a confirmed DL frame (mandatory if class C mode supported).
     *
     * Generated from protobuf field <code>uint32 class_c_timeout = 8;</code>
     * @return int
     */
    public function getClassCTimeout()
    {
        return $this->class_c_timeout;
    }

    /**
     * Maximum delay for the End-Device to answer a MAC request or a confirmed DL frame (mandatory if class C mode supported).
     *
     * Generated from protobuf field <code>uint32 class_c_timeout = 8;</code>
     * @param int $var
     * @return $this
     */
    public function setClassCTimeout($var)
    {
        GPBUtil::checkUint32($var);
        $this->class_c_timeout = $var;

        return $this;
    }

    /**
     * Version of the LoRaWAN supported by the End-Device.
     *
     * Generated from protobuf field <code>string mac_version = 9;</code>
     * @return string
     */
    public function getMacVersion()
    {
        return $this->mac_version;
    }

    /**
     * Version of the LoRaWAN supported by the End-Device.
     *
     * Generated from protobuf field <code>string mac_version = 9;</code>
     * @param string $var
     * @return $this
     */
    public function setMacVersion($var)
    {
        GPBUtil::checkString($var, True);
        $this->mac_version = $var;

        return $this;
    }

    /**
     * Revision of the Regional Parameters document supported by the End-Device.
     *
     * Generated from protobuf field <code>string reg_params_revision = 10;</code>
     * @return string
     */
    public function getRegParamsRevision()
    {
        return $this->reg_params_revision;
    }

    /**
     * Revision of the Regional Parameters document supported by the End-Device.
     *
     * Generated from protobuf field <code>string reg_params_revision = 10;</code>
     * @param string $var
     * @return $this
     */
    public function setRegParamsRevision($var)
    {
        GPBUtil::checkString($var, True);
        $this->reg_params_revision = $var;

        return $this;
    }

    /**
     * Class A RX1 delay (mandatory for ABP).
     *
     * Generated from protobuf field <code>uint32 rx_delay_1 = 11;</code>
     * @return int
     */
    public function getRxDelay1()
    {
        return $this->rx_delay_1;
    }

    /**
     * Class A RX1 delay (mandatory for ABP).
     *
     * Generated from protobuf field <code>uint32 rx_delay_1 = 11;</code>
     * @param int $var
     * @return $this
     */
    public function setRxDelay1($var)
    {
        GPBUtil::checkUint32($var);
        $this->rx_delay_1 = $var;

        return $this;
    }

    /**
     * RX1 data rate offset (mandatory for ABP).
     *
     * Generated from protobuf field <code>uint32 rx_dr_offset_1 = 12 [json_name = "rxDROffset1"];</code>
     * @return int
     */
    public function getRxDrOffset1()
    {
        return $this->rx_dr_offset_1;
    }

    /**
     * RX1 data rate offset (mandatory for ABP).
     *
     * Generated from protobuf field <code>uint32 rx_dr_offset_1 = 12 [json_name = "rxDROffset1"];</code>
     * @param int $var
     * @return $this
     */
    public function setRxDrOffset1($var)
    {
        GPBUtil::checkUint32($var);
        $this->rx_dr_offset_1 = $var;

        return $this;
    }

    /**
     * RX2 data rate (mandatory for ABP).
     *
     * Generated from protobuf field <code>uint32 rx_datarate_2 = 13 [json_name = "rxDataRate2"];</code>
     * @return int
     */
    public function getRxDatarate2()
    {
        return $this->rx_datarate_2;
    }

    /**
     * RX2 data rate (mandatory for ABP).
     *
     * Generated from protobuf field <code>uint32 rx_datarate_2 = 13 [json_name = "rxDataRate2"];</code>
     * @param int $var
     * @return $this
     */
    public function setRxDatarate2($var)
    {
        GPBUtil::checkUint32($var);
        $this->rx_datarate_2 = $var;

        return $this;
    }

    /**
     * RX2 channel frequency (mandatory for ABP).
     *
     * Generated from protobuf field <code>uint32 rx_freq_2 = 14;</code>
     * @return int
     */
    public function getRxFreq2()
    {
        return $this->rx_freq_2;
    }

    /**
     * RX2 channel frequency (mandatory for ABP).
     *
     * Generated from protobuf field <code>uint32 rx_freq_2 = 14;</code>
     * @param int $var
     * @return $this
     */
    public function setRxFreq2($var)
    {
        GPBUtil::checkUint32($var);
        $this->rx_freq_2 = $var;

        return $this;
    }

    /**
     * List of factory-preset frequencies (mandatory for ABP).
     *
     * Generated from protobuf field <code>repeated uint32 factory_preset_freqs = 15;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getFactoryPresetFreqs()
    {
        return $this->factory_preset_freqs;
    }

    /**
     * List of factory-preset frequencies (mandatory for ABP).
     *
     * Generated from protobuf field <code>repeated uint32 factory_preset_freqs = 15;</code>
     * @param array<int>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setFactoryPresetFreqs($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::UINT32);
        $this->factory_preset_freqs = $arr;

        return $this;
    }

    /**
     * Maximum EIRP supported by the End-Device.
     *
     * Generated from protobuf field <code>uint32 max_eirp = 16 [json_name = "maxEIRP"];</code>
     * @return int
     */
    public function getMaxEirp()
    {
        return $this->max_eirp;
    }

    /**
     * Maximum EIRP supported by the End-Device.
     *
     * Generated from protobuf field <code>uint32 max_eirp = 16 [json_name = "maxEIRP"];</code>
     * @param int $var
     * @return $this
     */
    public function setMaxEirp($var)
    {
        GPBUtil::checkUint32($var);
        $this->max_eirp = $var;

        return $this;
    }

    /**
     * Maximum duty cycle supported by the End-Device.
     *
     * Generated from protobuf field <code>uint32 max_duty_cycle = 17;</code>
     * @return int
     */
    public function getMaxDutyCycle()
    {
        return $this->max_duty_cycle;
    }

    /**
     * Maximum duty cycle supported by the End-Device.
     *
     * Generated from protobuf field <code>uint32 max_duty_cycle = 17;</code>
     * @param int $var
     * @return $this
     */
    public function setMaxDutyCycle($var)
    {
        GPBUtil::checkUint32($var);
        $this->max_duty_cycle = $var;

        return $this;
    }

    /**
     * End-Device supports Join (OTAA) or not (ABP).
     *
     * Generated from protobuf field <code>bool supports_join = 18;</code>
     * @return bool
     */
    public function getSupportsJoin()
    {
        return $this->supports_join;
    }

    /**
     * End-Device supports Join (OTAA) or not (ABP).
     *
     * Generated from protobuf field <code>bool supports_join = 18;</code>
     * @param bool $var
     * @return $this
     */
    public function setSupportsJoin($var)
    {
        GPBUtil::checkBool($var);
        $this->supports_join = $var;

        return $this;
    }

    /**
     * RF region name.
     *
     * Generated from protobuf field <code>string rf_region = 19;</code>
     * @return string
     */
    public function getRfRegion()
    {
        return $this->rf_region;
    }

    /**
     * RF region name.
     *
     * Generated from protobuf field <code>string rf_region = 19;</code>
     * @param string $var
     * @return $this
     */
    public function setRfRegion($var)
    {
        GPBUtil::checkString($var, True);
        $this->rf_region = $var;

        return $this;
    }

    /**
     * End-Device uses 32bit FCnt (mandatory for LoRaWAN 1.0 End-Device).
     *
     * Generated from protobuf field <code>bool supports_32bit_f_cnt = 20 [json_name = "supports32BitFCnt"];</code>
     * @return bool
     */
    public function getSupports32BitFCnt()
    {
        return $this->supports_32bit_f_cnt;
    }

    /**
     * End-Device uses 32bit FCnt (mandatory for LoRaWAN 1.0 End-Device).
     *
     * Generated from protobuf field <code>bool supports_32bit_f_cnt = 20 [json_name = "supports32BitFCnt"];</code>
     * @param bool $var
     * @return $this
     */
    public function setSupports32BitFCnt($var)
    {
        GPBUtil::checkBool($var);
        $this->supports_32bit_f_cnt = $var;

        return $this;
    }

    /**
     * Payload codec.
     * Leave blank to disable the codec feature.
     *
     * Generated from protobuf field <code>string payload_codec = 24;</code>
     * @return string
     */
    public function getPayloadCodec()
    {
        return $this->payload_codec;
    }

    /**
     * Payload codec.
     * Leave blank to disable the codec feature.
     *
     * Generated from protobuf field <code>string payload_codec = 24;</code>
     * @param string $var
     * @return $this
     */
    public function setPayloadCodec($var)
    {
        GPBUtil::checkString($var, True);
        $this->payload_codec = $var;

        return $this;
    }

    /**
     * Payload encoder script.
     * Depending the codec, it is possible to provide a script which implements
     * the encoder function.
     *
     * Generated from protobuf field <code>string payload_encoder_script = 25;</code>
     * @return string
     */
    public function getPayloadEncoderScript()
    {
        return $this->payload_encoder_script;
    }

    /**
     * Payload encoder script.
     * Depending the codec, it is possible to provide a script which implements
     * the encoder function.
     *
     * Generated from protobuf field <code>string payload_encoder_script = 25;</code>
     * @param string $var
     * @return $this
     */
    public function setPayloadEncoderScript($var)
    {
        GPBUtil::checkString($var, True);
        $this->payload_encoder_script = $var;

        return $this;
    }

    /**
     * Payload decoder script.
     * Depending the codec, it is possible to provide a script which implements
     * the decoder function.
     *
     * Generated from protobuf field <code>string payload_decoder_script = 26;</code>
     * @return string
     */
    public function getPayloadDecoderScript()
    {
        return $this->payload_decoder_script;
    }

    /**
     * Payload decoder script.
     * Depending the codec, it is possible to provide a script which implements
     * the decoder function.
     *
     * Generated from protobuf field <code>string payload_decoder_script = 26;</code>
     * @param string $var
     * @return $this
     */
    public function setPayloadDecoderScript($var)
    {
        GPBUtil::checkString($var, True);
        $this->payload_decoder_script = $var;

        return $this;
    }

    /**
     * Geolocation buffer TTL (in seconds).
     * When > 0, uplink RX meta-data will be stored in a buffer so that
     * the meta-data of multiple uplinks can be used for geolocation.
     *
     * Generated from protobuf field <code>uint32 geoloc_buffer_ttl = 27 [json_name = "geolocBufferTTL"];</code>
     * @return int
     */
    public function getGeolocBufferTtl()
    {
        return $this->geoloc_buffer_ttl;
    }

    /**
     * Geolocation buffer TTL (in seconds).
     * When > 0, uplink RX meta-data will be stored in a buffer so that
     * the meta-data of multiple uplinks can be used for geolocation.
     *
     * Generated from protobuf field <code>uint32 geoloc_buffer_ttl = 27 [json_name = "geolocBufferTTL"];</code>
     * @param int $var
     * @return $this
     */
    public function setGeolocBufferTtl($var)
    {
        GPBUtil::checkUint32($var);
        $this->geoloc_buffer_ttl = $var;

        return $this;
    }

    /**
     * Geolocation minimum buffer size.
     * When > 0, geolocation will only be performed when the buffer has
     * at least the given size.
     *
     * Generated from protobuf field <code>uint32 geoloc_min_buffer_size = 28;</code>
     * @return int
     */
    public function getGeolocMinBufferSize()
    {
        return $this->geoloc_min_buffer_size;
    }

    /**
     * Geolocation minimum buffer size.
     * When > 0, geolocation will only be performed when the buffer has
     * at least the given size.
     *
     * Generated from protobuf field <code>uint32 geoloc_min_buffer_size = 28;</code>
     * @param int $var
     * @return $this
     */
    public function setGeolocMinBufferSize($var)
    {
        GPBUtil::checkUint32($var);
        $this->geoloc_min_buffer_size = $var;

        return $this;
    }

    /**
     * User defined tags.
     *
     * Generated from protobuf field <code>map<string, string> tags = 29;</code>
     * @return \Google\Protobuf\Internal\MapField
     */
    public function getTags()
    {
        return $this->tags;
    }

    /**
     * User defined tags.
     *
     * Generated from protobuf field <code>map<string, string> tags = 29;</code>
     * @param array|\Google\Protobuf\Internal\MapField $var
     * @return $this
     */
    public function setTags($var)
    {
        $arr = GPBUtil::checkMapField($var, \Google\Protobuf\Internal\GPBType::STRING, \Google\Protobuf\Internal\GPBType::STRING);
        $this->tags = $arr;

        return $this;
    }

    /**
     * Uplink interval.
     * This defines the expected uplink interval which the device uses for
     * communication. When the uplink interval has expired and no uplink has
     * been received, the device is considered inactive.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration uplink_interval = 30;</code>
     * @return \Google\Protobuf\Duration|null
     */
    public function getUplinkInterval()
    {
        return $this->uplink_interval;
    }

    public function hasUplinkInterval()
    {
        return isset($this->uplink_interval);
    }

    public function clearUplinkInterval()
    {
        unset($this->uplink_interval);
    }

    /**
     * Uplink interval.
     * This defines the expected uplink interval which the device uses for
     * communication. When the uplink interval has expired and no uplink has
     * been received, the device is considered inactive.
     *
     * Generated from protobuf field <code>.google.protobuf.Duration uplink_interval = 30;</code>
     * @param \Google\Protobuf\Duration $var
     * @return $this
     */
    public function setUplinkInterval($var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Duration::class);
        $this->uplink_interval = $var;

        return $this;
    }

    /**
     * ADR algorithm ID.
     * In case this is left blank, or is configured to a non-existing ADR
     * algorithm (plugin), then it falls back to 'default'.
     *
     * Generated from protobuf field <code>string adr_algorithm_id = 31 [json_name = "adrAlgorithmID"];</code>
     * @return string
     */
    public function getAdrAlgorithmId()
    {
        return $this->adr_algorithm_id;
    }

    /**
     * ADR algorithm ID.
     * In case this is left blank, or is configured to a non-existing ADR
     * algorithm (plugin), then it falls back to 'default'.
     *
     * Generated from protobuf field <code>string adr_algorithm_id = 31 [json_name = "adrAlgorithmID"];</code>
     * @param string $var
     * @return $this
     */
    public function setAdrAlgorithmId($var)
    {
        GPBUtil::checkString($var, True);
        $this->adr_algorithm_id = $var;

        return $this;
    }

}

