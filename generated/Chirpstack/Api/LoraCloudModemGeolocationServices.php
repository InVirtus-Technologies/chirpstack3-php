<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: api/application.proto

namespace Chirpstack\Api;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Generated from protobuf message <code>api.LoraCloudModemGeolocationServices</code>
 */
class LoraCloudModemGeolocationServices extends \Google\Protobuf\Internal\Message
{
    /**
     * API token.
     *
     * Generated from protobuf field <code>string token = 1;</code>
     */
    protected $token = '';
    /**
     * Device implements Modem / Modem-E stack.
     *
     * Generated from protobuf field <code>bool modem_enabled = 2;</code>
     */
    protected $modem_enabled = false;
    /**
     * Forward FPorts.
     * Forward uplink messages matching the given FPorts to the MGS.
     *
     * Generated from protobuf field <code>repeated uint32 forward_f_ports = 16;</code>
     */
    private $forward_f_ports;
    /**
     * Use rx time for GNSS resolving.
     * In case this is set to true, the MGS resolver will use the RX time of the
     * network instead of the timestamp included in the LR1110 payload.
     *
     * Generated from protobuf field <code>bool gnss_use_rx_time = 5;</code>
     */
    protected $gnss_use_rx_time = false;
    /**
     * Use gateway location for GNSS resolving.
     * In the case this is set to true, ChirpStack will provide the location of
     * one of the gateways to the MGS resolver to aid the resolving process.
     * Disable this in case the gateway location is not accurate / incorrectly
     * configured as an incorrect location will cause the resolver to return an
     * error.
     *
     * Generated from protobuf field <code>bool gnss_use_gateway_location = 17;</code>
     */
    protected $gnss_use_gateway_location = false;
    /**
     * Parse TLV records.
     * If enabled, stream records (expected in TLV format) are scanned for GNSS
     * data (0x06 or 0x07). If found, ChirpStack will make an additional
     * geolocation call to the MGS API for resolving the location of the detected
     * payload.
     *
     * Generated from protobuf field <code>bool parse_tlv = 6;</code>
     */
    protected $parse_tlv = false;
    /**
     * Geolocation buffer TTL (in seconds).
     * If > 0, uplink RX meta-data will be stored in a buffer so that
     * the meta-data of multiple uplinks can be used for geolocation.
     *
     * Generated from protobuf field <code>uint32 geolocation_buffer_ttl = 7;</code>
     */
    protected $geolocation_buffer_ttl = 0;
    /**
     * Geolocation minimum buffer size.
     * If > 0, geolocation will only be performed when the buffer has
     * at least the given size.
     *
     * Generated from protobuf field <code>uint32 geolocation_min_buffer_size = 8;</code>
     */
    protected $geolocation_min_buffer_size = 0;
    /**
     * TDOA based geolocation is enabled.
     *
     * Generated from protobuf field <code>bool geolocation_tdoa = 9;</code>
     */
    protected $geolocation_tdoa = false;
    /**
     * RSSI based geolocation is enabled.
     *
     * Generated from protobuf field <code>bool geolocation_rssi = 10;</code>
     */
    protected $geolocation_rssi = false;
    /**
     * GNSS based geolocation is enabled (LR1110).
     *
     * Generated from protobuf field <code>bool geolocation_gnss = 11;</code>
     */
    protected $geolocation_gnss = false;
    /**
     * GNSS payload field.
     * This holds the name of the field in the decoded payload object which
     * contains the GNSS payload bytes (as HEX string).
     *
     * Generated from protobuf field <code>string geolocation_gnss_payload_field = 12;</code>
     */
    protected $geolocation_gnss_payload_field = '';
    /**
     * GNSS use RX time.
     * In case this is set to true, the resolver will use the RX time of the
     * network instead of the timestamp included in the LR1110 payload.
     *
     * Generated from protobuf field <code>bool geolocation_gnss_use_rx_time = 13;</code>
     */
    protected $geolocation_gnss_use_rx_time = false;
    /**
     * Wifi based geolocation is enabled.
     *
     * Generated from protobuf field <code>bool geolocation_wifi = 14;</code>
     */
    protected $geolocation_wifi = false;
    /**
     * Wifi payload field.
     * This holds the name of the field in the decoded payload object which
     * contains an array of objects with the following fields:
     * * macAddress - e.g. 01:23:45:67:89:ab
     * * signalStrength - e.g. -51 (optional)
     *
     * Generated from protobuf field <code>string geolocation_wifi_payload_field = 15;</code>
     */
    protected $geolocation_wifi_payload_field = '';

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $token
     *           API token.
     *     @type bool $modem_enabled
     *           Device implements Modem / Modem-E stack.
     *     @type array<int>|\Google\Protobuf\Internal\RepeatedField $forward_f_ports
     *           Forward FPorts.
     *           Forward uplink messages matching the given FPorts to the MGS.
     *     @type bool $gnss_use_rx_time
     *           Use rx time for GNSS resolving.
     *           In case this is set to true, the MGS resolver will use the RX time of the
     *           network instead of the timestamp included in the LR1110 payload.
     *     @type bool $gnss_use_gateway_location
     *           Use gateway location for GNSS resolving.
     *           In the case this is set to true, ChirpStack will provide the location of
     *           one of the gateways to the MGS resolver to aid the resolving process.
     *           Disable this in case the gateway location is not accurate / incorrectly
     *           configured as an incorrect location will cause the resolver to return an
     *           error.
     *     @type bool $parse_tlv
     *           Parse TLV records.
     *           If enabled, stream records (expected in TLV format) are scanned for GNSS
     *           data (0x06 or 0x07). If found, ChirpStack will make an additional
     *           geolocation call to the MGS API for resolving the location of the detected
     *           payload.
     *     @type int $geolocation_buffer_ttl
     *           Geolocation buffer TTL (in seconds).
     *           If > 0, uplink RX meta-data will be stored in a buffer so that
     *           the meta-data of multiple uplinks can be used for geolocation.
     *     @type int $geolocation_min_buffer_size
     *           Geolocation minimum buffer size.
     *           If > 0, geolocation will only be performed when the buffer has
     *           at least the given size.
     *     @type bool $geolocation_tdoa
     *           TDOA based geolocation is enabled.
     *     @type bool $geolocation_rssi
     *           RSSI based geolocation is enabled.
     *     @type bool $geolocation_gnss
     *           GNSS based geolocation is enabled (LR1110).
     *     @type string $geolocation_gnss_payload_field
     *           GNSS payload field.
     *           This holds the name of the field in the decoded payload object which
     *           contains the GNSS payload bytes (as HEX string).
     *     @type bool $geolocation_gnss_use_rx_time
     *           GNSS use RX time.
     *           In case this is set to true, the resolver will use the RX time of the
     *           network instead of the timestamp included in the LR1110 payload.
     *     @type bool $geolocation_wifi
     *           Wifi based geolocation is enabled.
     *     @type string $geolocation_wifi_payload_field
     *           Wifi payload field.
     *           This holds the name of the field in the decoded payload object which
     *           contains an array of objects with the following fields:
     *           * macAddress - e.g. 01:23:45:67:89:ab
     *           * signalStrength - e.g. -51 (optional)
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Chirpstack\Api\Application::initOnce();
        parent::__construct($data);
    }

    /**
     * API token.
     *
     * Generated from protobuf field <code>string token = 1;</code>
     * @return string
     */
    public function getToken()
    {
        return $this->token;
    }

    /**
     * API token.
     *
     * Generated from protobuf field <code>string token = 1;</code>
     * @param string $var
     * @return $this
     */
    public function setToken($var)
    {
        GPBUtil::checkString($var, True);
        $this->token = $var;

        return $this;
    }

    /**
     * Device implements Modem / Modem-E stack.
     *
     * Generated from protobuf field <code>bool modem_enabled = 2;</code>
     * @return bool
     */
    public function getModemEnabled()
    {
        return $this->modem_enabled;
    }

    /**
     * Device implements Modem / Modem-E stack.
     *
     * Generated from protobuf field <code>bool modem_enabled = 2;</code>
     * @param bool $var
     * @return $this
     */
    public function setModemEnabled($var)
    {
        GPBUtil::checkBool($var);
        $this->modem_enabled = $var;

        return $this;
    }

    /**
     * Forward FPorts.
     * Forward uplink messages matching the given FPorts to the MGS.
     *
     * Generated from protobuf field <code>repeated uint32 forward_f_ports = 16;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getForwardFPorts()
    {
        return $this->forward_f_ports;
    }

    /**
     * Forward FPorts.
     * Forward uplink messages matching the given FPorts to the MGS.
     *
     * Generated from protobuf field <code>repeated uint32 forward_f_ports = 16;</code>
     * @param array<int>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setForwardFPorts($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::UINT32);
        $this->forward_f_ports = $arr;

        return $this;
    }

    /**
     * Use rx time for GNSS resolving.
     * In case this is set to true, the MGS resolver will use the RX time of the
     * network instead of the timestamp included in the LR1110 payload.
     *
     * Generated from protobuf field <code>bool gnss_use_rx_time = 5;</code>
     * @return bool
     */
    public function getGnssUseRxTime()
    {
        return $this->gnss_use_rx_time;
    }

    /**
     * Use rx time for GNSS resolving.
     * In case this is set to true, the MGS resolver will use the RX time of the
     * network instead of the timestamp included in the LR1110 payload.
     *
     * Generated from protobuf field <code>bool gnss_use_rx_time = 5;</code>
     * @param bool $var
     * @return $this
     */
    public function setGnssUseRxTime($var)
    {
        GPBUtil::checkBool($var);
        $this->gnss_use_rx_time = $var;

        return $this;
    }

    /**
     * Use gateway location for GNSS resolving.
     * In the case this is set to true, ChirpStack will provide the location of
     * one of the gateways to the MGS resolver to aid the resolving process.
     * Disable this in case the gateway location is not accurate / incorrectly
     * configured as an incorrect location will cause the resolver to return an
     * error.
     *
     * Generated from protobuf field <code>bool gnss_use_gateway_location = 17;</code>
     * @return bool
     */
    public function getGnssUseGatewayLocation()
    {
        return $this->gnss_use_gateway_location;
    }

    /**
     * Use gateway location for GNSS resolving.
     * In the case this is set to true, ChirpStack will provide the location of
     * one of the gateways to the MGS resolver to aid the resolving process.
     * Disable this in case the gateway location is not accurate / incorrectly
     * configured as an incorrect location will cause the resolver to return an
     * error.
     *
     * Generated from protobuf field <code>bool gnss_use_gateway_location = 17;</code>
     * @param bool $var
     * @return $this
     */
    public function setGnssUseGatewayLocation($var)
    {
        GPBUtil::checkBool($var);
        $this->gnss_use_gateway_location = $var;

        return $this;
    }

    /**
     * Parse TLV records.
     * If enabled, stream records (expected in TLV format) are scanned for GNSS
     * data (0x06 or 0x07). If found, ChirpStack will make an additional
     * geolocation call to the MGS API for resolving the location of the detected
     * payload.
     *
     * Generated from protobuf field <code>bool parse_tlv = 6;</code>
     * @return bool
     */
    public function getParseTlv()
    {
        return $this->parse_tlv;
    }

    /**
     * Parse TLV records.
     * If enabled, stream records (expected in TLV format) are scanned for GNSS
     * data (0x06 or 0x07). If found, ChirpStack will make an additional
     * geolocation call to the MGS API for resolving the location of the detected
     * payload.
     *
     * Generated from protobuf field <code>bool parse_tlv = 6;</code>
     * @param bool $var
     * @return $this
     */
    public function setParseTlv($var)
    {
        GPBUtil::checkBool($var);
        $this->parse_tlv = $var;

        return $this;
    }

    /**
     * Geolocation buffer TTL (in seconds).
     * If > 0, uplink RX meta-data will be stored in a buffer so that
     * the meta-data of multiple uplinks can be used for geolocation.
     *
     * Generated from protobuf field <code>uint32 geolocation_buffer_ttl = 7;</code>
     * @return int
     */
    public function getGeolocationBufferTtl()
    {
        return $this->geolocation_buffer_ttl;
    }

    /**
     * Geolocation buffer TTL (in seconds).
     * If > 0, uplink RX meta-data will be stored in a buffer so that
     * the meta-data of multiple uplinks can be used for geolocation.
     *
     * Generated from protobuf field <code>uint32 geolocation_buffer_ttl = 7;</code>
     * @param int $var
     * @return $this
     */
    public function setGeolocationBufferTtl($var)
    {
        GPBUtil::checkUint32($var);
        $this->geolocation_buffer_ttl = $var;

        return $this;
    }

    /**
     * Geolocation minimum buffer size.
     * If > 0, geolocation will only be performed when the buffer has
     * at least the given size.
     *
     * Generated from protobuf field <code>uint32 geolocation_min_buffer_size = 8;</code>
     * @return int
     */
    public function getGeolocationMinBufferSize()
    {
        return $this->geolocation_min_buffer_size;
    }

    /**
     * Geolocation minimum buffer size.
     * If > 0, geolocation will only be performed when the buffer has
     * at least the given size.
     *
     * Generated from protobuf field <code>uint32 geolocation_min_buffer_size = 8;</code>
     * @param int $var
     * @return $this
     */
    public function setGeolocationMinBufferSize($var)
    {
        GPBUtil::checkUint32($var);
        $this->geolocation_min_buffer_size = $var;

        return $this;
    }

    /**
     * TDOA based geolocation is enabled.
     *
     * Generated from protobuf field <code>bool geolocation_tdoa = 9;</code>
     * @return bool
     */
    public function getGeolocationTdoa()
    {
        return $this->geolocation_tdoa;
    }

    /**
     * TDOA based geolocation is enabled.
     *
     * Generated from protobuf field <code>bool geolocation_tdoa = 9;</code>
     * @param bool $var
     * @return $this
     */
    public function setGeolocationTdoa($var)
    {
        GPBUtil::checkBool($var);
        $this->geolocation_tdoa = $var;

        return $this;
    }

    /**
     * RSSI based geolocation is enabled.
     *
     * Generated from protobuf field <code>bool geolocation_rssi = 10;</code>
     * @return bool
     */
    public function getGeolocationRssi()
    {
        return $this->geolocation_rssi;
    }

    /**
     * RSSI based geolocation is enabled.
     *
     * Generated from protobuf field <code>bool geolocation_rssi = 10;</code>
     * @param bool $var
     * @return $this
     */
    public function setGeolocationRssi($var)
    {
        GPBUtil::checkBool($var);
        $this->geolocation_rssi = $var;

        return $this;
    }

    /**
     * GNSS based geolocation is enabled (LR1110).
     *
     * Generated from protobuf field <code>bool geolocation_gnss = 11;</code>
     * @return bool
     */
    public function getGeolocationGnss()
    {
        return $this->geolocation_gnss;
    }

    /**
     * GNSS based geolocation is enabled (LR1110).
     *
     * Generated from protobuf field <code>bool geolocation_gnss = 11;</code>
     * @param bool $var
     * @return $this
     */
    public function setGeolocationGnss($var)
    {
        GPBUtil::checkBool($var);
        $this->geolocation_gnss = $var;

        return $this;
    }

    /**
     * GNSS payload field.
     * This holds the name of the field in the decoded payload object which
     * contains the GNSS payload bytes (as HEX string).
     *
     * Generated from protobuf field <code>string geolocation_gnss_payload_field = 12;</code>
     * @return string
     */
    public function getGeolocationGnssPayloadField()
    {
        return $this->geolocation_gnss_payload_field;
    }

    /**
     * GNSS payload field.
     * This holds the name of the field in the decoded payload object which
     * contains the GNSS payload bytes (as HEX string).
     *
     * Generated from protobuf field <code>string geolocation_gnss_payload_field = 12;</code>
     * @param string $var
     * @return $this
     */
    public function setGeolocationGnssPayloadField($var)
    {
        GPBUtil::checkString($var, True);
        $this->geolocation_gnss_payload_field = $var;

        return $this;
    }

    /**
     * GNSS use RX time.
     * In case this is set to true, the resolver will use the RX time of the
     * network instead of the timestamp included in the LR1110 payload.
     *
     * Generated from protobuf field <code>bool geolocation_gnss_use_rx_time = 13;</code>
     * @return bool
     */
    public function getGeolocationGnssUseRxTime()
    {
        return $this->geolocation_gnss_use_rx_time;
    }

    /**
     * GNSS use RX time.
     * In case this is set to true, the resolver will use the RX time of the
     * network instead of the timestamp included in the LR1110 payload.
     *
     * Generated from protobuf field <code>bool geolocation_gnss_use_rx_time = 13;</code>
     * @param bool $var
     * @return $this
     */
    public function setGeolocationGnssUseRxTime($var)
    {
        GPBUtil::checkBool($var);
        $this->geolocation_gnss_use_rx_time = $var;

        return $this;
    }

    /**
     * Wifi based geolocation is enabled.
     *
     * Generated from protobuf field <code>bool geolocation_wifi = 14;</code>
     * @return bool
     */
    public function getGeolocationWifi()
    {
        return $this->geolocation_wifi;
    }

    /**
     * Wifi based geolocation is enabled.
     *
     * Generated from protobuf field <code>bool geolocation_wifi = 14;</code>
     * @param bool $var
     * @return $this
     */
    public function setGeolocationWifi($var)
    {
        GPBUtil::checkBool($var);
        $this->geolocation_wifi = $var;

        return $this;
    }

    /**
     * Wifi payload field.
     * This holds the name of the field in the decoded payload object which
     * contains an array of objects with the following fields:
     * * macAddress - e.g. 01:23:45:67:89:ab
     * * signalStrength - e.g. -51 (optional)
     *
     * Generated from protobuf field <code>string geolocation_wifi_payload_field = 15;</code>
     * @return string
     */
    public function getGeolocationWifiPayloadField()
    {
        return $this->geolocation_wifi_payload_field;
    }

    /**
     * Wifi payload field.
     * This holds the name of the field in the decoded payload object which
     * contains an array of objects with the following fields:
     * * macAddress - e.g. 01:23:45:67:89:ab
     * * signalStrength - e.g. -51 (optional)
     *
     * Generated from protobuf field <code>string geolocation_wifi_payload_field = 15;</code>
     * @param string $var
     * @return $this
     */
    public function setGeolocationWifiPayloadField($var)
    {
        GPBUtil::checkString($var, True);
        $this->geolocation_wifi_payload_field = $var;

        return $this;
    }

}

